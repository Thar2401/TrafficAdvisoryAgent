# Test models functionality\n\nimport unittest\nimport pandas as pd\nimport numpy as np\nimport sys\nimport os\n\n# Add parent directory to path\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom models.traffic_predictor import TrafficPredictor\nfrom models.route_optimizer import RouteOptimizer\nfrom models.sustainability_calculator import SustainabilityCalculator\nfrom utils.data_generator import TrafficDataGenerator\nfrom utils.config import Config\n\nclass TestTrafficPredictor(unittest.TestCase):\n    \"\"\"Test cases for traffic prediction model\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Set up test fixtures\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(30)\n        cls.test_data = generator.generate_traffic_patterns(routes, days=14)\n        \n        # Initialize and train predictor\n        cls.predictor = TrafficPredictor()\n        cls.training_metrics = cls.predictor.train(cls.test_data)\n    \n    def test_model_training(self):\n        \"\"\"Test model training\"\"\"\n        self.assertTrue(self.predictor.is_trained)\n        self.assertIn('test_r2', self.training_metrics)\n        self.assertIn('train_r2', self.training_metrics)\n        \n        # R² score should be reasonable (>= 0 for valid model)\n        self.assertGreaterEqual(self.training_metrics['test_r2'], 0)\n    \n    def test_feature_preparation(self):\n        \"\"\"Test feature preparation\"\"\"\n        features = self.predictor.prepare_features(self.test_data)\n        \n        # Should have encoded categorical features\n        self.assertIn('source_encoded', features.columns)\n        self.assertIn('destination_encoded', features.columns)\n        \n        # Should have time-based features\n        self.assertIn('is_weekend', features.columns)\n        self.assertIn('is_rush_hour', features.columns)\n        self.assertIn('hour_sin', features.columns)\n        self.assertIn('hour_cos', features.columns)\n    \n    def test_prediction(self):\n        \"\"\"Test prediction functionality\"\"\"\n        # Create test prediction data\n        test_input = pd.DataFrame([{\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'distance_km': 15.0,\n            'hour': 8,\n            'day_of_week': 1,\n            'traffic_level': 'medium'\n        }])\n        \n        predictions = self.predictor.predict(test_input)\n        \n        self.assertEqual(len(predictions), 1)\n        self.assertGreaterEqual(predictions[0], 0.0)\n        self.assertLessEqual(predictions[0], 1.0)\n    \n    def test_single_prediction(self):\n        \"\"\"Test single route prediction\"\"\"\n        prediction = self.predictor.predict_congestion_level(\n            source='Downtown',\n            destination='Airport', \n            hour=8,\n            day_of_week=1,\n            distance_km=15.0\n        )\n        \n        self.assertIn('congestion_score', prediction)\n        self.assertIn('traffic_level', prediction)\n        self.assertIn('source', prediction)\n        self.assertIn('destination', prediction)\n        \n        # Validate congestion score range\n        self.assertGreaterEqual(prediction['congestion_score'], 0.0)\n        self.assertLessEqual(prediction['congestion_score'], 1.0)\n    \n    def test_feature_importance(self):\n        \"\"\"Test feature importance extraction\"\"\"\n        importance = self.predictor.get_feature_importance()\n        \n        self.assertIsInstance(importance, dict)\n        self.assertGreater(len(importance), 0)\n        \n        # All importance values should be non-negative\n        for value in importance.values():\n            self.assertGreaterEqual(value, 0.0)\n\nclass TestRouteOptimizer(unittest.TestCase):\n    \"\"\"Test cases for route optimization\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(20)\n        self.test_data = generator.generate_traffic_patterns(routes, days=7)\n        \n        self.optimizer = RouteOptimizer(self.test_data)\n    \n    def test_distance_calculation(self):\n        \"\"\"Test distance calculation between locations\"\"\"\n        distance = self.optimizer.calculate_distance('Downtown', 'Airport')\n        \n        self.assertIsInstance(distance, float)\n        self.assertGreater(distance, 0)\n        self.assertLess(distance, 100)  # Reasonable urban distance\n    \n    def test_alternative_routes_generation(self):\n        \"\"\"Test alternative route generation\"\"\"\n        alternatives = self.optimizer.find_alternative_routes('Downtown', 'Airport')\n        \n        self.assertIsInstance(alternatives, list)\n        self.assertGreater(len(alternatives), 0)\n        \n        # Check route structure\n        for route in alternatives:\n            self.assertIn('route_type', route)\n            self.assertIn('description', route)\n            self.assertIn('waypoints', route)\n            self.assertIn('distance_km', route)\n    \n    def test_route_evaluation(self):\n        \"\"\"Test route evaluation at specific time\"\"\"\n        route = {\n            'route_type': 'direct',\n            'description': 'Downtown → Airport',\n            'waypoints': ['Downtown', 'Airport'],\n            'distance_km': 15.0,\n            'route_factor': 1.0\n        }\n        \n        evaluation = self.optimizer.evaluate_route_at_time(route, hour=8, day_of_week=1)\n        \n        # Check required fields\n        required_fields = [\n            'congestion_score', 'traffic_level', 'avg_speed_kmh',\n            'travel_time_min', 'fuel_consumption_l', 'co2_emission_kg'\n        ]\n        \n        for field in required_fields:\n            self.assertIn(field, evaluation)\n        \n        # Validate value ranges\n        self.assertGreaterEqual(evaluation['congestion_score'], 0.0)\n        self.assertLessEqual(evaluation['congestion_score'], 1.0)\n        self.assertGreater(evaluation['avg_speed_kmh'], 0)\n        self.assertGreater(evaluation['travel_time_min'], 0)\n    \n    def test_travel_optimization(self):\n        \"\"\"Test travel time optimization\"\"\"\n        optimization = self.optimizer.optimize_travel_time(\n            source='Downtown',\n            destination='Airport',\n            preferred_hour=8,\n            day_of_week=1\n        )\n        \n        self.assertIn('source', optimization)\n        self.assertIn('destination', optimization)\n        self.assertIn('best_time', optimization)\n        self.assertIn('best_fuel_efficiency', optimization)\n        self.assertIn('best_environmental', optimization)\n        \n        # Best time should have valid structure\n        best_time = optimization['best_time']\n        self.assertIn('travel_time_min', best_time)\n        self.assertIn('congestion_score', best_time)\n\nclass TestSustainabilityCalculator(unittest.TestCase):\n    \"\"\"Test cases for sustainability calculations\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.calculator = SustainabilityCalculator()\n    \n    def test_route_impact_calculation(self):\n        \"\"\"Test route impact calculation\"\"\"\n        impact = self.calculator.calculate_route_impact(distance_km=10, travel_mode='car_gasoline')\n        \n        # Check required fields\n        required_fields = [\n            'travel_mode', 'distance_km', 'co2_emission_kg',\n            'energy_consumption_kwh', 'estimated_cost', 'sustainability_score'\n        ]\n        \n        for field in required_fields:\n            self.assertIn(field, impact)\n        \n        # Validate value ranges\n        self.assertGreater(impact['co2_emission_kg'], 0)\n        self.assertGreater(impact['energy_consumption_kwh'], 0)\n        self.assertGreater(impact['estimated_cost'], 0)\n        self.assertGreaterEqual(impact['sustainability_score'], 0)\n        self.assertLessEqual(impact['sustainability_score'], 100)\n    \n    def test_transportation_mode_comparison(self):\n        \"\"\"Test transportation mode comparison\"\"\"\n        comparison = self.calculator.compare_transportation_modes(distance_km=10)\n        \n        self.assertIsInstance(comparison, list)\n        self.assertGreater(len(comparison), 0)\n        \n        # Should be sorted by sustainability score (descending)\n        scores = [mode['sustainability_score'] for mode in comparison]\n        self.assertEqual(scores, sorted(scores, reverse=True))\n        \n        # Walking should be most sustainable\n        self.assertEqual(comparison[0]['travel_mode'], 'walking')\n    \n    def test_congestion_impact_adjustment(self):\n        \"\"\"Test congestion impact on emissions\"\"\"\n        base_impact = self.calculator.calculate_route_impact(10, 'car_gasoline')\n        \n        # Test with different congestion levels\n        low_congestion_impact = self.calculator.calculate_congestion_impact(base_impact, 0.2)\n        high_congestion_impact = self.calculator.calculate_congestion_impact(base_impact, 0.8)\n        \n        # High congestion should result in higher emissions\n        self.assertGreater(\n            high_congestion_impact['co2_emission_kg'],\n            low_congestion_impact['co2_emission_kg']\n        )\n        \n        # Should include congestion penalty\n        self.assertIn('congestion_penalty', low_congestion_impact)\n        self.assertIn('congestion_penalty', high_congestion_impact)\n    \n    def test_sustainability_recommendations(self):\n        \"\"\"Test sustainability recommendation generation\"\"\"\n        recommendations = self.calculator.generate_sustainability_recommendations(\n            distance_km=5, current_co2_kg=1.0\n        )\n        \n        self.assertIsInstance(recommendations, list)\n        self.assertGreater(len(recommendations), 0)\n        \n        # Should contain actionable recommendations\n        rec_text = ' '.join(recommendations)\n        self.assertTrue(any(word in rec_text.lower() for word in ['walk', 'cycle', 'public', 'electric']))\n    \n    def test_annual_impact_calculation(self):\n        \"\"\"Test annual impact projection\"\"\"\n        daily_routes = [\n            {'co2_emission_kg': 2.0, 'distance_km': 15, 'estimated_cost': 3.0},\n            {'co2_emission_kg': 1.5, 'distance_km': 10, 'estimated_cost': 2.0}\n        ]\n        \n        annual_impact = self.calculator.calculate_annual_impact(daily_routes, days_per_year=250)\n        \n        # Check required fields\n        required_fields = [\n            'daily_co2_kg', 'annual_co2_kg', 'annual_distance_km',\n            'trees_needed_to_offset', 'gasoline_equivalent_liters'\n        ]\n        \n        for field in required_fields:\n            self.assertIn(field, annual_impact)\n        \n        # Validate calculations\n        expected_daily_co2 = 2.0 + 1.5\n        expected_annual_co2 = expected_daily_co2 * 250\n        \n        self.assertAlmostEqual(annual_impact['daily_co2_kg'], expected_daily_co2, places=1)\n        self.assertAlmostEqual(annual_impact['annual_co2_kg'], expected_annual_co2, places=1)\n\nclass TestModelIntegration(unittest.TestCase):\n    \"\"\"Test integration between different models\"\"\"\n    \n    def test_predictor_optimizer_integration(self):\n        \"\"\"Test integration between traffic predictor and route optimizer\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(15)\n        test_data = generator.generate_traffic_patterns(routes, days=10)\n        \n        # Initialize and train predictor\n        predictor = TrafficPredictor()\n        predictor.train(test_data)\n        \n        # Initialize optimizer\n        optimizer = RouteOptimizer(test_data)\n        \n        # Test integrated workflow\n        alternatives = optimizer.find_alternative_routes('Downtown', 'Airport')\n        \n        for route in alternatives[:3]:  # Test first 3 alternatives\n            evaluation = optimizer.evaluate_route_at_time(\n                route, hour=8, day_of_week=1, traffic_predictor=predictor\n            )\n            \n            # Should have all required fields\n            self.assertIn('congestion_score', evaluation)\n            self.assertIn('travel_time_min', evaluation)\n            self.assertIn('co2_emission_kg', evaluation)\n    \n    def test_optimizer_sustainability_integration(self):\n        \"\"\"Test integration between route optimizer and sustainability calculator\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(10)\n        test_data = generator.generate_traffic_patterns(routes, days=7)\n        \n        optimizer = RouteOptimizer(test_data)\n        calculator = SustainabilityCalculator()\n        \n        # Get route evaluations\n        alternatives = optimizer.find_alternative_routes('Downtown', 'Airport')\n        evaluations = []\n        \n        for route in alternatives:\n            evaluation = optimizer.evaluate_route_at_time(route, hour=8, day_of_week=1)\n            evaluations.append(evaluation)\n        \n        # Calculate sustainability\n        sustainability_analysis = calculator.calculate_route_alternatives_sustainability(evaluations)\n        \n        # Should have sustainability comparison\n        self.assertIn('route_sustainability', sustainability_analysis)\n        self.assertIn('best_environmental_option', sustainability_analysis)\n        self.assertIn('potential_co2_savings_kg', sustainability_analysis)\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)"