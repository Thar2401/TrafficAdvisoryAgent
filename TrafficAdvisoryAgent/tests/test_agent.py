# Unit tests for Traffic Advisory Agent\n\nimport unittest\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add parent directory to path\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom src.traffic_agent import TrafficAdvisoryAgent\nfrom utils.data_generator import TrafficDataGenerator\nfrom utils.validators import InputValidator\nfrom utils.config import Config\n\nclass TestTrafficAdvisoryAgent(unittest.TestCase):\n    \"\"\"Test cases for the main Traffic Advisory Agent\"\"\"\n    \n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Set up test fixtures before running tests\"\"\"\n        cls.agent = TrafficAdvisoryAgent(auto_load_data=True)\n    \n    def test_agent_initialization(self):\n        \"\"\"Test agent initialization\"\"\"\n        self.assertTrue(self.agent.is_initialized)\n        self.assertTrue(self.agent.model_trained)\n        self.assertIsNotNone(self.agent.traffic_data)\n    \n    def test_basic_route_request(self):\n        \"\"\"Test basic route planning request\"\"\"\n        recommendations = self.agent.process_request(\n            source=\"Downtown\",\n            destination=\"Airport\",\n            preferred_time=\"08:00\"\n        )\n        \n        self.assertNotIn('error', recommendations)\n        self.assertIn('primary_recommendation', recommendations)\n        self.assertIn('alternative_options', recommendations)\n    \n    def test_invalid_input_handling(self):\n        \"\"\"Test handling of invalid inputs\"\"\"\n        # Test same source and destination\n        recommendations = self.agent.process_request(\n            source=\"Downtown\",\n            destination=\"Downtown\"\n        )\n        \n        self.assertIn('error', recommendations)\n    \n    def test_traffic_insights(self):\n        \"\"\"Test traffic insights functionality\"\"\"\n        insights = self.agent.get_traffic_insights(\n            location=\"Downtown\",\n            hour=8\n        )\n        \n        self.assertIsInstance(insights, dict)\n        self.assertIn('general_patterns', insights)\n    \n    def test_sustainability_report(self):\n        \"\"\"Test sustainability analysis\"\"\"\n        route_data = {'distance_km': 10, 'co2_emission_kg': 2.0}\n        report = self.agent.get_sustainability_report(route_data)\n        \n        self.assertIn('transportation_mode_comparison', report)\n        self.assertIn('recommendations', report)\n\nclass TestDataGenerator(unittest.TestCase):\n    \"\"\"Test cases for traffic data generation\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.generator = TrafficDataGenerator()\n    \n    def test_route_generation(self):\n        \"\"\"Test route generation\"\"\"\n        routes = self.generator.generate_routes(num_routes=10)\n        \n        self.assertEqual(len(routes), 10)\n        self.assertTrue(all('route_id' in route for route in routes))\n        self.assertTrue(all('source' in route for route in routes))\n        self.assertTrue(all('destination' in route for route in routes))\n    \n    def test_traffic_pattern_generation(self):\n        \"\"\"Test traffic pattern generation\"\"\"\n        routes = self.generator.generate_routes(num_routes=5)\n        dataset = self.generator.generate_traffic_patterns(routes, days=7)\n        \n        self.assertIsInstance(dataset, pd.DataFrame)\n        self.assertTrue(len(dataset) > 0)\n        \n        # Check required columns\n        required_columns = [\n            'route_id', 'source', 'destination', 'distance_km',\n            'hour', 'day_of_week', 'traffic_level', 'congestion_score'\n        ]\n        \n        for col in required_columns:\n            self.assertIn(col, dataset.columns)\n    \n    def test_congestion_calculation(self):\n        \"\"\"Test congestion score calculation\"\"\"\n        # Test rush hour\n        morning_congestion = self.generator._calculate_congestion_score(8, 1)  # 8 AM, Tuesday\n        self.assertGreater(morning_congestion, 0.6)  # Should be high\n        \n        # Test off-peak hour\n        night_congestion = self.generator._calculate_congestion_score(2, 1)  # 2 AM, Tuesday\n        self.assertLess(night_congestion, 0.4)  # Should be low\n\nclass TestInputValidator(unittest.TestCase):\n    \"\"\"Test cases for input validation\"\"\"\n    \n    def test_location_validation(self):\n        \"\"\"Test location string validation\"\"\"\n        # Valid locations\n        self.assertTrue(InputValidator.validate_location(\"Downtown\"))\n        self.assertTrue(InputValidator.validate_location(\"New York City\"))\n        self.assertTrue(InputValidator.validate_location(\"Area-51\"))\n        \n        # Invalid locations\n        self.assertFalse(InputValidator.validate_location(\"\"))  # Empty\n        self.assertFalse(InputValidator.validate_location(\"A\"))  # Too short\n        self.assertFalse(InputValidator.validate_location(\"A\" * 101))  # Too long\n        self.assertFalse(InputValidator.validate_location(None))  # None\n    \n    def test_time_validation(self):\n        \"\"\"Test time string validation\"\"\"\n        # Valid times\n        self.assertEqual(InputValidator.validate_time_preference(\"08:30\"), 8)\n        self.assertEqual(InputValidator.validate_time_preference(\"14\"), 14)\n        self.assertEqual(InputValidator.validate_time_preference(\"00:00\"), 0)\n        self.assertEqual(InputValidator.validate_time_preference(\"23:59\"), 23)\n        \n        # Invalid times\n        self.assertIsNone(InputValidator.validate_time_preference(\"25:00\"))  # Invalid hour\n        self.assertIsNone(InputValidator.validate_time_preference(\"abc\"))  # Non-numeric\n        self.assertIsNone(InputValidator.validate_time_preference(\"\"))  # Empty\n        self.assertIsNone(InputValidator.validate_time_preference(None))  # None\n    \n    def test_congestion_score_validation(self):\n        \"\"\"Test congestion score validation\"\"\"\n        # Valid scores\n        self.assertTrue(InputValidator.validate_congestion_score(0.0))\n        self.assertTrue(InputValidator.validate_congestion_score(0.5))\n        self.assertTrue(InputValidator.validate_congestion_score(1.0))\n        \n        # Invalid scores\n        self.assertFalse(InputValidator.validate_congestion_score(-0.1))\n        self.assertFalse(InputValidator.validate_congestion_score(1.1))\n        self.assertFalse(InputValidator.validate_congestion_score(\"0.5\"))  # String\n    \n    def test_route_data_validation(self):\n        \"\"\"Test route data validation\"\"\"\n        # Valid route data\n        valid_route = {\n            'route_id': 'R001',\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'distance_km': 15.5,\n            'hour': 8,\n            'day_of_week': 1,\n            'traffic_level': 'high',\n            'congestion_score': 0.7,\n            'avg_speed_kmh': 35.0,\n            'travel_time_min': 26.7,\n            'fuel_consumption_l': 1.24,\n            'co2_emission_kg': 2.86\n        }\n        \n        is_valid, message = InputValidator.validate_route_data(valid_route)\n        self.assertTrue(is_valid)\n        self.assertEqual(message, \"Valid\")\n        \n        # Invalid route data - missing field\n        invalid_route = valid_route.copy()\n        del invalid_route['source']\n        \n        is_valid, message = InputValidator.validate_route_data(invalid_route)\n        self.assertFalse(is_valid)\n        self.assertIn(\"Missing required fields\", message)\n\nclass TestConfiguration(unittest.TestCase):\n    \"\"\"Test cases for configuration\"\"\"\n    \n    def test_traffic_level_conversion(self):\n        \"\"\"Test traffic level score conversion\"\"\"\n        # Test score to level conversion\n        self.assertEqual(Config.get_traffic_level_from_score(0.1), 'low')\n        self.assertEqual(Config.get_traffic_level_from_score(0.5), 'medium')\n        self.assertEqual(Config.get_traffic_level_from_score(0.7), 'high')\n        self.assertEqual(Config.get_traffic_level_from_score(0.9), 'severe')\n    \n    def test_config_values(self):\n        \"\"\"Test configuration values\"\"\"\n        self.assertEqual(Config.HOURS_IN_DAY, 24)\n        self.assertEqual(Config.DAYS_IN_WEEK, 7)\n        self.assertGreater(Config.MAX_ALTERNATIVE_ROUTES, 0)\n        self.assertGreater(len(Config.DEMO_LOCATIONS), 0)\n\nclass TestIntegration(unittest.TestCase):\n    \"\"\"Integration tests for the complete system\"\"\"\n    \n    def test_end_to_end_workflow(self):\n        \"\"\"Test complete end-to-end workflow\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(num_routes=20)\n        dataset = generator.generate_traffic_patterns(routes, days=7)\n        \n        # Initialize agent with test data\n        agent = TrafficAdvisoryAgent(auto_load_data=False)\n        agent.traffic_data = dataset\n        agent.perception.traffic_data = dataset\n        agent.perception.data_loaded = True\n        agent.perception.last_update = datetime.now()\n        \n        # Train model\n        processed_data = agent.perception.preprocess_traffic_data()\n        training_metrics = agent.traffic_predictor.train(processed_data)\n        agent.model_trained = True\n        \n        # Initialize route optimizer\n        from models.route_optimizer import RouteOptimizer\n        agent.route_optimizer = RouteOptimizer(processed_data)\n        agent.is_initialized = True\n        \n        # Test request processing\n        locations = agent.perception.get_available_locations()\n        if len(locations) >= 2:\n            recommendations = agent.process_request(\n                source=locations[0],\n                destination=locations[1],\n                preferred_time=\"09:00\"\n            )\n            \n            # Verify results\n            self.assertNotIn('error', recommendations)\n            self.assertIn('primary_recommendation', recommendations)\n            self.assertIn('analysis_details', recommendations)\n            \n            # Check recommendation structure\n            primary = recommendations['primary_recommendation']\n            self.assertIn('route_description', primary)\n            self.assertIn('travel_metrics', primary)\n            self.assertIn('environmental_impact', primary)\n\ndef run_performance_test():\n    \"\"\"Run performance benchmarks\"\"\"\n    print(\"\\nðŸƒâ€â™‚ï¸ Running Performance Tests...\")\n    \n    import time\n    \n    # Test data generation performance\n    start_time = time.time()\n    generator = TrafficDataGenerator()\n    routes = generator.generate_routes(100)\n    dataset = generator.generate_traffic_patterns(routes, days=30)\n    generation_time = time.time() - start_time\n    \n    print(f\"   â€¢ Data generation: {generation_time:.2f}s for {len(dataset)} records\")\n    \n    # Test agent initialization performance\n    start_time = time.time()\n    agent = TrafficAdvisoryAgent(auto_load_data=True)\n    init_time = time.time() - start_time\n    \n    print(f\"   â€¢ Agent initialization: {init_time:.2f}s\")\n    \n    # Test request processing performance\n    locations = agent.perception.get_available_locations()\n    if len(locations) >= 2:\n        start_time = time.time()\n        \n        for i in range(5):\n            agent.process_request(\n                source=locations[0],\n                destination=locations[1],\n                preferred_time=f\"{8+i:02d}:00\"\n            )\n        \n        avg_request_time = (time.time() - start_time) / 5\n        print(f\"   â€¢ Average request processing: {avg_request_time:.2f}s\")\n    \n    print(\"   âœ… Performance tests completed\")\n\nif __name__ == '__main__':\n    # Run unit tests\n    print(\"ðŸ§ª Running Unit Tests...\")\n    unittest.main(argv=[''], exit=False, verbosity=2)\n    \n    # Run performance tests\n    run_performance_test()\n    \n    print(\"\\nðŸŽ¯ All tests completed!\")