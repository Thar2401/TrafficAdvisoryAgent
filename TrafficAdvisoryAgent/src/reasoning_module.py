# Reasoning module - Traffic analysis and prediction logic

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta
from collections import defaultdict
import statistics

from utils.config import Config

class ReasoningModule:
    """
    Handles traffic analysis, pattern recognition, and prediction logic
    This is the REASONING component of the agentic workflow
    """
    
    def __init__(self):
        """Initialize reasoning module"""
        self.traffic_patterns = None
        self.peak_hour_analysis = None
        self.route_analysis = None
        self.weather_impact = None  # Future enhancement
    
    def analyze_congestion_patterns(self, traffic_data: pd.DataFrame) -> Dict:
        \"\"\"
        Analyze traffic congestion patterns from historical data
        
        Args:
            traffic_data: Historical traffic data
            
        Returns:
            Dict: Congestion pattern analysis
        \"\"\"
        pattern_analysis = {}\n        \n        # Hourly patterns\n        hourly_congestion = traffic_data.groupby('hour')['congestion_score'].agg([\n            'mean', 'std', 'min', 'max', 'count'\n        ]).round(3)\n        \n        pattern_analysis['hourly_patterns'] = hourly_congestion.to_dict('index')\n        \n        # Daily patterns (day of week)\n        daily_congestion = traffic_data.groupby('day_of_week')['congestion_score'].agg([\n            'mean', 'std', 'min', 'max', 'count'\n        ]).round(3)\n        \n        # Map day numbers to names\n        day_names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        daily_patterns_named = {}\n        for day_num, stats in daily_congestion.to_dict('index').items():\n            daily_patterns_named[day_names[day_num]] = stats\n        \n        pattern_analysis['daily_patterns'] = daily_patterns_named\n        \n        # Route-specific patterns\n        route_congestion = traffic_data.groupby(['source', 'destination'])['congestion_score'].agg([\n            'mean', 'std', 'count'\n        ]).round(3)\n        \n        # Convert to more readable format\n        route_patterns = {}\n        for (source, dest), stats in route_congestion.to_dict('index').items():\n            route_key = f\"{source} â†’ {dest}\"\n            route_patterns[route_key] = stats\n        \n        pattern_analysis['route_patterns'] = route_patterns\n        \n        # Combined hour-day patterns\n        hour_day_patterns = traffic_data.groupby(['hour', 'day_of_week'])['congestion_score'].mean().unstack()\n        pattern_analysis['hour_day_heatmap'] = hour_day_patterns.round(3).to_dict()\n        \n        return pattern_analysis\n    \n    def identify_peak_hours(self, traffic_data: pd.DataFrame, \n                           threshold: float = None) -> Dict:\n        \"\"\"\n        Identify peak traffic hours and periods\n        \n        Args:\n            traffic_data: Historical traffic data\n            threshold: Congestion threshold for peak classification\n            \n        Returns:\n            Dict: Peak hour analysis\n        \"\"\"\n        if threshold is None:\n            threshold = Config.CONGESTION_THRESHOLD\n        \n        # Calculate average congestion by hour\n        hourly_avg = traffic_data.groupby('hour')['congestion_score'].mean()\n        \n        # Identify peak hours\n        peak_hours = hourly_avg[hourly_avg >= threshold].index.tolist()\n        \n        # Separate weekday and weekend patterns\n        weekday_data = traffic_data[~traffic_data['day_of_week'].isin([5, 6])]\n        weekend_data = traffic_data[traffic_data['day_of_week'].isin([5, 6])]\n        \n        weekday_peaks = weekday_data.groupby('hour')['congestion_score'].mean()\n        weekend_peaks = weekend_data.groupby('hour')['congestion_score'].mean()\n        \n        weekday_peak_hours = weekday_peaks[weekday_peaks >= threshold].index.tolist()\n        weekend_peak_hours = weekend_peaks[weekend_peaks >= threshold].index.tolist()\n        \n        # Find peak periods (consecutive peak hours)\n        def find_consecutive_periods(hours):\n            if not hours:\n                return []\n            \n            periods = []\n            start = hours[0]\n            end = start\n            \n            for i in range(1, len(hours)):\n                if hours[i] == end + 1:\n                    end = hours[i]\n                else:\n                    periods.append((start, end))\n                    start = hours[i]\n                    end = start\n            \n            periods.append((start, end))\n            return periods\n        \n        peak_periods = find_consecutive_periods(sorted(peak_hours))\n        weekday_peak_periods = find_consecutive_periods(sorted(weekday_peak_hours))\n        weekend_peak_periods = find_consecutive_periods(sorted(weekend_peak_hours))\n        \n        # Calculate severity levels\n        severity_levels = {\n            'low': (0.0, 0.3),\n            'medium': (0.3, 0.6),\n            'high': (0.6, 0.8),\n            'severe': (0.8, 1.0)\n        }\n        \n        hour_severity = {}\n        for hour in range(24):\n            avg_congestion = hourly_avg.get(hour, 0)\n            for level, (min_val, max_val) in severity_levels.items():\n                if min_val <= avg_congestion < max_val:\n                    hour_severity[hour] = level\n                    break\n            else:\n                hour_severity[hour] = 'severe'\n        \n        peak_analysis = {\n            'threshold_used': threshold,\n            'overall_peak_hours': peak_hours,\n            'weekday_peak_hours': weekday_peak_hours,\n            'weekend_peak_hours': weekend_peak_hours,\n            'peak_periods': peak_periods,\n            'weekday_peak_periods': weekday_peak_periods,\n            'weekend_peak_periods': weekend_peak_periods,\n            'hourly_severity': hour_severity,\n            'hourly_average_congestion': hourly_avg.round(3).to_dict(),\n            'weekday_hourly_congestion': weekday_peaks.round(3).to_dict(),\n            'weekend_hourly_congestion': weekend_peaks.round(3).to_dict()\n        }\n        \n        return peak_analysis\n    \n    def predict_congestion(self, user_input: Dict, traffic_data: pd.DataFrame,\n                         traffic_predictor=None) -> Dict:\n        \"\"\"\n        Predict traffic congestion for user's route and time\n        \n        Args:\n            user_input: Parsed user input\n            traffic_data: Historical traffic data\n            traffic_predictor: Optional ML predictor model\n            \n        Returns:\n            Dict: Congestion prediction results\n        \"\"\"\n        source = user_input['source']\n        destination = user_input['destination']\n        preferred_hour = user_input.get('preferred_hour', user_input['current_hour'])\n        current_day_of_week = user_input['current_day_of_week']\n        \n        # Try ML prediction first if available\n        ml_prediction = None\n        if traffic_predictor and traffic_predictor.is_trained:\n            try:\n                ml_prediction = traffic_predictor.predict_congestion_level(\n                    source, destination, preferred_hour, current_day_of_week\n                )\n            except Exception as e:\n                print(f\"ML prediction failed: {e}, falling back to historical analysis\")\n        \n        # Historical analysis fallback\n        historical_prediction = self._predict_from_historical_patterns(\n            source, destination, preferred_hour, current_day_of_week, traffic_data\n        )\n        \n        # Combine predictions if ML is available\n        if ml_prediction:\n            # Weight ML prediction higher if we have it\n            combined_score = (ml_prediction['congestion_score'] * 0.7 + \n                            historical_prediction['congestion_score'] * 0.3)\n            \n            prediction_result = {\n                'source': source,\n                'destination': destination,\n                'hour': preferred_hour,\n                'day_of_week': current_day_of_week,\n                'predicted_congestion_score': round(combined_score, 3),\n                'predicted_traffic_level': Config.get_traffic_level_from_score(combined_score),\n                'ml_prediction': ml_prediction,\n                'historical_prediction': historical_prediction,\n                'prediction_method': 'combined',\n                'confidence': 0.85\n            }\n        else:\n            prediction_result = {\n                **historical_prediction,\n                'prediction_method': 'historical',\n                'confidence': 0.65\n            }\n        \n        return prediction_result\n    \n    def _predict_from_historical_patterns(self, source: str, destination: str,\n                                        hour: int, day_of_week: int,\n                                        traffic_data: pd.DataFrame) -> Dict:\n        \"\"\"\n        Predict congestion based on historical patterns\n        \n        Args:\n            source: Source location\n            destination: Destination location\n            hour: Hour of day (0-23)\n            day_of_week: Day of week (0-6)\n            traffic_data: Historical traffic data\n            \n        Returns:\n            Dict: Historical-based prediction\n        \"\"\"\n        # Filter for exact route if available\n        route_data = traffic_data[\n            (traffic_data['source'] == source) &\n            (traffic_data['destination'] == destination)\n        ]\n        \n        if len(route_data) == 0:\n            # No exact match, use general patterns\n            return self._predict_from_general_patterns(hour, day_of_week, traffic_data)\n        \n        # Filter by time\n        time_filtered = route_data[\n            (route_data['hour'] == hour) &\n            (route_data['day_of_week'] == day_of_week)\n        ]\n        \n        if len(time_filtered) > 0:\n            # Exact time match\n            avg_congestion = time_filtered['congestion_score'].mean()\n            std_congestion = time_filtered['congestion_score'].std()\n        else:\n            # Use same hour across different days\n            hour_data = route_data[route_data['hour'] == hour]\n            if len(hour_data) > 0:\n                avg_congestion = hour_data['congestion_score'].mean()\n                std_congestion = hour_data['congestion_score'].std()\n            else:\n                # Use overall route average\n                avg_congestion = route_data['congestion_score'].mean()\n                std_congestion = route_data['congestion_score'].std()\n        \n        return {\n            'source': source,\n            'destination': destination,\n            'hour': hour,\n            'day_of_week': day_of_week,\n            'predicted_congestion_score': round(avg_congestion, 3),\n            'predicted_traffic_level': Config.get_traffic_level_from_score(avg_congestion),\n            'confidence_std': round(std_congestion, 3) if not pd.isna(std_congestion) else 0.0,\n            'data_points': len(time_filtered) if len(time_filtered) > 0 else len(route_data)\n        }\n    \n    def _predict_from_general_patterns(self, hour: int, day_of_week: int,\n                                     traffic_data: pd.DataFrame) -> Dict:\n        \"\"\"\n        Predict using general traffic patterns when specific route data is unavailable\n        \n        Args:\n            hour: Hour of day (0-23)\n            day_of_week: Day of week (0-6)\n            traffic_data: Historical traffic data\n            \n        Returns:\n            Dict: General pattern-based prediction\n        \"\"\"\n        # Use general time patterns\n        time_data = traffic_data[\n            (traffic_data['hour'] == hour) &\n            (traffic_data['day_of_week'] == day_of_week)\n        ]\n        \n        if len(time_data) > 0:\n            avg_congestion = time_data['congestion_score'].mean()\n        else:\n            # Fallback to hour-only pattern\n            hour_data = traffic_data[traffic_data['hour'] == hour]\n            avg_congestion = hour_data['congestion_score'].mean() if len(hour_data) > 0 else 0.5\n        \n        return {\n            'source': 'Unknown',\n            'destination': 'Unknown',\n            'hour': hour,\n            'day_of_week': day_of_week,\n            'predicted_congestion_score': round(avg_congestion, 3),\n            'predicted_traffic_level': Config.get_traffic_level_from_score(avg_congestion),\n            'confidence_std': 0.2,  # Higher uncertainty for general patterns\n            'data_points': len(time_data)\n        }\n    \n    def calculate_travel_patterns(self, traffic_data: pd.DataFrame) -> Dict:\n        \"\"\"\n        Calculate comprehensive travel patterns and insights\n        \n        Args:\n            traffic_data: Historical traffic data\n            \n        Returns:\n            Dict: Travel pattern analysis\n        \"\"\"\n        patterns = {}\n        \n        # Speed patterns\n        speed_by_hour = traffic_data.groupby('hour')['avg_speed_kmh'].agg(['mean', 'min', 'max'])\n        patterns['speed_patterns'] = speed_by_hour.round(1).to_dict('index')\n        \n        # Travel time patterns\n        time_by_hour = traffic_data.groupby('hour')['travel_time_min'].agg(['mean', 'min', 'max'])\n        patterns['travel_time_patterns'] = time_by_hour.round(1).to_dict('index')\n        \n        # Distance vs congestion analysis\n        distance_bins = pd.cut(traffic_data['distance_km'], bins=5, labels=['Very Short', 'Short', 'Medium', 'Long', 'Very Long'])\n        distance_congestion = traffic_data.groupby(distance_bins)['congestion_score'].mean()\n        patterns['distance_congestion_correlation'] = distance_congestion.round(3).to_dict()\n        \n        # Route popularity (frequency)\n        route_frequency = traffic_data.groupby(['source', 'destination']).size().sort_values(ascending=False)\n        top_routes = route_frequency.head(10).to_dict()\n        top_routes_formatted = {f\"{k[0]} â†’ {k[1]}\": v for k, v in top_routes.items()}\n        patterns['most_popular_routes'] = top_routes_formatted\n        \n        # Congestion hotspots\n        location_congestion = defaultdict(list)\n        for _, row in traffic_data.iterrows():\n            location_congestion[row['source']].append(row['congestion_score'])\n            location_congestion[row['destination']].append(row['congestion_score'])\n        \n        location_avg_congestion = {}\n        for location, scores in location_congestion.items():\n            location_avg_congestion[location] = round(statistics.mean(scores), 3)\n        \n        # Sort by congestion level\n        sorted_locations = sorted(location_avg_congestion.items(), key=lambda x: x[1], reverse=True)\n        patterns['congestion_hotspots'] = dict(sorted_locations[:10])\n        \n        return patterns\n    \n    def generate_insights(self, analysis_results: Dict) -> List[str]:\n        \"\"\"\n        Generate actionable insights from traffic analysis\n        \n        Args:\n            analysis_results: Results from various analysis methods\n            \n        Returns:\n            List[str]: List of insights and recommendations\n        \"\"\"\n        insights = []\n        \n        # Peak hour insights\n        if 'peak_analysis' in analysis_results:\n            peak_data = analysis_results['peak_analysis']\n            \n            if peak_data['weekday_peak_hours']:\n                morning_peaks = [h for h in peak_data['weekday_peak_hours'] if 6 <= h <= 10]\n                evening_peaks = [h for h in peak_data['weekday_peak_hours'] if 16 <= h <= 20]\n                \n                if morning_peaks:\n                    insights.append(\n                        f\"ðŸŒ… Morning rush hour: {min(morning_peaks):02d}:00-{max(morning_peaks):02d}:00. \"\n                        f\"Consider traveling before {min(morning_peaks):02d}:00 or after {max(morning_peaks)+1:02d}:00.\"\n                    )\n                \n                if evening_peaks:\n                    insights.append(\n                        f\"ðŸŒ† Evening rush hour: {min(evening_peaks):02d}:00-{max(evening_peaks):02d}:00. \"\n                        f\"Consider flexible work hours or leaving earlier/later.\"\n                    )\n        \n        # Congestion pattern insights\n        if 'congestion_patterns' in analysis_results:\n            hourly_patterns = analysis_results['congestion_patterns']['hourly_patterns']\n            \n            # Find best travel hours\n            best_hours = sorted(hourly_patterns.items(), key=lambda x: x[1]['mean'])[:3]\n            best_hours_str = \", \".join([f\"{h:02d}:00\" for h, _ in best_hours])\n            \n            insights.append(\n                f\"â° Best travel times: {best_hours_str} (lowest average congestion)\"\n            )\n            \n            # Find worst travel hours\n            worst_hours = sorted(hourly_patterns.items(), key=lambda x: x[1]['mean'], reverse=True)[:3]\n            worst_hours_str = \", \".join([f\"{h:02d}:00\" for h, _ in worst_hours])\n            \n            insights.append(\n                f\"ðŸš« Avoid these times: {worst_hours_str} (highest average congestion)\"\n            )\n        \n        # Route-specific insights\n        if 'travel_patterns' in analysis_results:\n            patterns = analysis_results['travel_patterns']\n            \n            if 'congestion_hotspots' in patterns:\n                hotspots = list(patterns['congestion_hotspots'].keys())[:3]\n                insights.append(\n                    f\"ðŸ”¥ Traffic hotspots to avoid: {', '.join(hotspots)}\"\n                )\n        \n        # Weekend vs weekday insights\n        if 'peak_analysis' in analysis_results:\n            peak_data = analysis_results['peak_analysis']\n            weekday_avg = np.mean(list(peak_data['weekday_hourly_congestion'].values()))\n            weekend_avg = np.mean(list(peak_data['weekend_hourly_congestion'].values()))\n            \n            if weekend_avg < weekday_avg * 0.8:\n                insights.append(\n                    f\"ðŸ“… Weekends have {((weekday_avg - weekend_avg) / weekday_avg * 100):.0f}% \"\n                    f\"less traffic on average. Consider weekend trips when possible.\"\n                )\n        \n        return insights"