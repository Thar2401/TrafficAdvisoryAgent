# Decision module - Route and time optimization

import pandas as pd
import numpy as np\nfrom typing import Dict, List, Tuple, Optional\nfrom datetime import datetime, timedelta\nimport heapq\n\nfrom utils.config import Config\n\nclass DecisionModule:\n    \"\"\"\n    Handles route optimization, time selection, and decision-making logic\n    This is the DECISION-MAKING component of the agentic workflow\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize decision module\"\"\"\n        self.optimization_weights = {\n            'travel_time': 0.4,\n            'congestion': 0.3,\n            'fuel_efficiency': 0.2,\n            'environmental_impact': 0.1\n        }\n    \n    def find_best_travel_time(self, congestion_forecast: Dict,\n                             time_flexibility_hours: int = 3) -> Dict:\n        \"\"\"\n        Find optimal travel time based on congestion forecast\n        \n        Args:\n            congestion_forecast: Predicted congestion data\n            time_flexibility_hours: How many hours of flexibility user has\n            \n        Returns:\n            Dict: Optimal travel time recommendation\n        \"\"\"\n        preferred_hour = congestion_forecast.get('hour', datetime.now().hour)\n        day_of_week = congestion_forecast.get('day_of_week', datetime.now().weekday())\n        \n        # Generate time options within flexibility window\n        time_options = []\n        for offset in range(-time_flexibility_hours, time_flexibility_hours + 1):\n            test_hour = (preferred_hour + offset) % 24\n            \n            # Estimate congestion for this time\n            # In a real system, this would use the prediction model\n            estimated_congestion = self._estimate_congestion_for_time(\n                test_hour, day_of_week\n            )\n            \n            # Calculate score (lower is better)\n            time_score = self._calculate_time_score(\n                test_hour, estimated_congestion, preferred_hour\n            )\n            \n            time_options.append({\n                'hour': test_hour,\n                'estimated_congestion': estimated_congestion,\n                'deviation_from_preferred': abs(offset),\n                'time_score': time_score,\n                'formatted_time': f\"{test_hour:02d}:00\",\n                'recommendation_level': self._get_recommendation_level(time_score)\n            })\n        \n        # Sort by score (best first)\n        time_options.sort(key=lambda x: x['time_score'])\n        \n        best_time = time_options[0]\n        alternatives = time_options[1:4]  # Top 3 alternatives\n        \n        return {\n            'preferred_hour': preferred_hour,\n            'optimal_time': best_time,\n            'alternatives': alternatives,\n            'flexibility_window_hours': time_flexibility_hours,\n            'all_options': time_options\n        }\n    \n    def _estimate_congestion_for_time(self, hour: int, day_of_week: int) -> float:\n        \"\"\"\n        Estimate congestion score for a given time (simplified heuristic)\n        \n        Args:\n            hour: Hour of day (0-23)\n            day_of_week: Day of week (0-6)\n            \n        Returns:\n            float: Estimated congestion score (0.0-1.0)\n        \"\"\"\n        # Weekend pattern\n        if day_of_week in [5, 6]:  # Saturday, Sunday\n            if 10 <= hour <= 20:\n                return np.random.uniform(0.3, 0.5)\n            else:\n                return np.random.uniform(0.1, 0.3)\n        \n        # Weekday pattern\n        if 7 <= hour <= 9:  # Morning rush\n            return np.random.uniform(0.7, 0.9)\n        elif 17 <= hour <= 19:  # Evening rush\n            return np.random.uniform(0.6, 0.8)\n        elif 10 <= hour <= 16:  # Daytime\n            return np.random.uniform(0.4, 0.6)\n        elif 20 <= hour <= 22:  # Evening\n            return np.random.uniform(0.3, 0.5)\n        else:  # Night/early morning\n            return np.random.uniform(0.1, 0.3)\n    \n    def _calculate_time_score(self, hour: int, congestion: float, \n                            preferred_hour: int) -> float:\n        \"\"\"\n        Calculate score for a time option (lower is better)\n        \n        Args:\n            hour: Hour being evaluated\n            congestion: Estimated congestion level\n            preferred_hour: User's preferred hour\n            \n        Returns:\n            float: Time option score\n        \"\"\"\n        # Congestion penalty (0-100)\n        congestion_penalty = congestion * 100\n        \n        # Time deviation penalty (exponential)\n        time_deviation = abs(hour - preferred_hour)\n        if time_deviation > 12:  # Handle day wraparound\n            time_deviation = 24 - time_deviation\n        deviation_penalty = time_deviation ** 1.5 * 10\n        \n        # Antisocial hours penalty (very early/late)\n        antisocial_penalty = 0\n        if hour < 6 or hour > 23:\n            antisocial_penalty = 20\n        elif hour < 7 or hour > 22:\n            antisocial_penalty = 10\n        \n        total_score = congestion_penalty + deviation_penalty + antisocial_penalty\n        return round(total_score, 2)\n    \n    def _get_recommendation_level(self, score: float) -> str:\n        \"\"\"\n        Convert score to recommendation level\n        \n        Args:\n            score: Time option score\n            \n        Returns:\n            str: Recommendation level\n        \"\"\"\n        if score <= 30:\n            return 'excellent'\n        elif score <= 50:\n            return 'good'\n        elif score <= 70:\n            return 'fair'\n        else:\n            return 'poor'\n    \n    def find_alternative_routes(self, source: str, destination: str,\n                              route_optimizer=None, max_routes: int = None) -> List[Dict]:\n        \"\"\"\n        Find and rank alternative routes\n        \n        Args:\n            source: Source location\n            destination: Destination location\n            route_optimizer: Route optimization model\n            max_routes: Maximum number of routes to return\n            \n        Returns:\n            List[Dict]: Ranked alternative routes\n        \"\"\"\n        if max_routes is None:\n            max_routes = Config.MAX_ALTERNATIVE_ROUTES\n        \n        if route_optimizer:\n            # Use the route optimizer to find alternatives\n            alternatives = route_optimizer.find_alternative_routes(\n                source, destination, max_routes\n            )\n        else:\n            # Fallback: create basic alternatives\n            alternatives = self._create_basic_alternatives(source, destination, max_routes)\n        \n        # Score and rank alternatives\n        scored_routes = []\n        for route in alternatives:\n            score = self._score_route(route)\n            scored_route = {**route, 'route_score': score}\n            scored_routes.append(scored_route)\n        \n        # Sort by score (lower is better)\n        scored_routes.sort(key=lambda x: x['route_score'])\n        \n        return scored_routes[:max_routes]\n    \n    def _create_basic_alternatives(self, source: str, destination: str, \n                                 max_routes: int) -> List[Dict]:\n        \"\"\"\n        Create basic alternative routes (fallback method)\n        \n        Args:\n            source: Source location\n            destination: Destination location\n            max_routes: Maximum routes to create\n            \n        Returns:\n            List[Dict]: Basic route alternatives\n        \"\"\"\n        alternatives = []\n        \n        # Direct route\n        base_distance = np.random.uniform(10, 30)\n        alternatives.append({\n            'route_type': 'direct',\n            'description': f'{source} â†’ {destination}',\n            'waypoints': [source, destination],\n            'distance_km': round(base_distance, 2),\n            'route_factor': 1.0\n        })\n        \n        # Alternative routes with different characteristics\n        route_variations = [\n            ('highway', 1.1, 'Highway Route (faster but potentially more congested)'),\n            ('scenic', 1.3, 'Scenic Route (longer but less traffic)'),\n            ('local', 0.9, 'Local Roads (shorter but more stops)')\n        ]\n        \n        for route_type, factor, description in route_variations[:max_routes-1]:\n            alternatives.append({\n                'route_type': route_type,\n                'description': f'{source} â†’ {destination} ({route_type})',\n                'waypoints': [source, destination],\n                'distance_km': round(base_distance * factor, 2),\n                'route_factor': factor\n            })\n        \n        return alternatives\n    \n    def _score_route(self, route: Dict) -> float:\n        \"\"\"\n        Score a route based on multiple criteria\n        \n        Args:\n            route: Route dictionary\n            \n        Returns:\n            float: Route score (lower is better)\n        \"\"\"\n        # Distance penalty\n        distance_score = route['distance_km'] * 2  # 2 points per km\n        \n        # Route factor penalty (longer routes)\n        factor_penalty = (route.get('route_factor', 1.0) - 1.0) * 50\n        \n        # Route type bonus/penalty\n        type_modifiers = {\n            'direct': 0,\n            'highway': 10,   # Potentially faster but more congested\n            'scenic': 5,     # Longer but pleasant\n            'local': -5,     # Shorter but more stops\n            'via_waypoint': 15  # Additional complexity\n        }\n        \n        type_modifier = type_modifiers.get(route.get('route_type', 'direct'), 0)\n        \n        total_score = distance_score + factor_penalty + type_modifier\n        return round(total_score, 2)\n    \n    def optimize_multi_criteria(self, route_evaluations: List[Dict],\n                              user_preferences: Dict = None) -> Dict:\n        \"\"\"\n        Perform multi-criteria optimization for route selection\n        \n        Args:\n            route_evaluations: List of evaluated routes with metrics\n            user_preferences: User preference weights\n            \n        Returns:\n            Dict: Multi-criteria optimization results\n        \"\"\"\n        if not route_evaluations:\n            return {'error': 'No route evaluations provided'}\n        \n        # Use user preferences or defaults\n        weights = user_preferences or self.optimization_weights\n        \n        # Normalize weights to sum to 1\n        total_weight = sum(weights.values())\n        normalized_weights = {k: v/total_weight for k, v in weights.items()}\n        \n        # Score each route\n        scored_routes = []\n        \n        # Get min/max values for normalization\n        all_travel_times = [r['travel_time_min'] for r in route_evaluations]\n        all_congestion = [r['congestion_score'] for r in route_evaluations]\n        all_fuel = [r['fuel_consumption_l'] for r in route_evaluations]\n        all_co2 = [r['co2_emission_kg'] for r in route_evaluations]\n        \n        min_time, max_time = min(all_travel_times), max(all_travel_times)\n        min_congestion, max_congestion = min(all_congestion), max(all_congestion)\n        min_fuel, max_fuel = min(all_fuel), max(all_fuel)\n        min_co2, max_co2 = min(all_co2), max(all_co2)\n        \n        for route in route_evaluations:\n            # Normalize metrics to 0-1 scale (0 = best, 1 = worst)\n            time_norm = self._normalize_value(route['travel_time_min'], min_time, max_time)\n            congestion_norm = self._normalize_value(route['congestion_score'], min_congestion, max_congestion)\n            fuel_norm = self._normalize_value(route['fuel_consumption_l'], min_fuel, max_fuel)\n            co2_norm = self._normalize_value(route['co2_emission_kg'], min_co2, max_co2)\n            \n            # Calculate weighted score\n            weighted_score = (\n                normalized_weights['travel_time'] * time_norm +\n                normalized_weights['congestion'] * congestion_norm +\n                normalized_weights['fuel_efficiency'] * fuel_norm +\n                normalized_weights['environmental_impact'] * co2_norm\n            )\n            \n            scored_route = {\n                **route,\n                'normalized_scores': {\n                    'travel_time': round(time_norm, 3),\n                    'congestion': round(congestion_norm, 3),\n                    'fuel_efficiency': round(fuel_norm, 3),\n                    'environmental_impact': round(co2_norm, 3)\n                },\n                'weighted_score': round(weighted_score, 3),\n                'rank_by_score': 0  # Will be set after sorting\n            }\n            \n            scored_routes.append(scored_route)\n        \n        # Sort by weighted score (lower is better)\n        scored_routes.sort(key=lambda x: x['weighted_score'])\n        \n        # Assign ranks\n        for i, route in enumerate(scored_routes):\n            route['rank_by_score'] = i + 1\n        \n        # Find best in each category\n        best_time = min(route_evaluations, key=lambda x: x['travel_time_min'])\n        best_congestion = min(route_evaluations, key=lambda x: x['congestion_score'])\n        best_fuel = min(route_evaluations, key=lambda x: x['fuel_consumption_l'])\n        best_co2 = min(route_evaluations, key=lambda x: x['co2_emission_kg'])\n        \n        optimization_result = {\n            'optimization_weights': normalized_weights,\n            'ranked_routes': scored_routes,\n            'best_overall': scored_routes[0],\n            'category_winners': {\n                'fastest': best_time,\n                'least_congested': best_congestion,\n                'most_fuel_efficient': best_fuel,\n                'most_environmentally_friendly': best_co2\n            },\n            'evaluation_summary': {\n                'total_routes_evaluated': len(route_evaluations),\n                'time_range_min': f\"{min_time:.1f} - {max_time:.1f}\",\n                'congestion_range': f\"{min_congestion:.3f} - {max_congestion:.3f}\",\n                'fuel_range_l': f\"{min_fuel:.3f} - {max_fuel:.3f}\",\n                'co2_range_kg': f\"{min_co2:.3f} - {max_co2:.3f}\"\n            }\n        }\n        \n        return optimization_result\n    \n    def _normalize_value(self, value: float, min_val: float, max_val: float) -> float:\n        \"\"\"\n        Normalize value to 0-1 range\n        \n        Args:\n            value: Value to normalize\n            min_val: Minimum value in range\n            max_val: Maximum value in range\n            \n        Returns:\n            float: Normalized value (0-1)\n        \"\"\"\n        if max_val == min_val:\n            return 0.0\n        return (value - min_val) / (max_val - min_val)\n    \n    def generate_decision_explanation(self, decision_result: Dict) -> str:\n        \"\"\"\n        Generate human-readable explanation for decision\n        \n        Args:\n            decision_result: Result from optimization\n            \n        Returns:\n            str: Decision explanation\n        \"\"\"\n        if 'best_overall' not in decision_result:\n            return \"No optimal route could be determined.\"\n        \n        best_route = decision_result['best_overall']\n        \n        explanation_parts = [\n            f\"ðŸŽ¯ **Recommended Route**: {best_route['description']}\",\n            f\"ðŸ“ **Distance**: {best_route['distance_km']} km\",\n            f\"â±ï¸ **Travel Time**: {best_route['travel_time_min']} minutes\",\n            f\"ðŸš¦ **Traffic Level**: {best_route['traffic_level']}\",\n            f\"â›½ **Fuel Consumption**: {best_route['fuel_consumption_l']} L\",\n            f\"ðŸŒ± **CO2 Emissions**: {best_route['co2_emission_kg']} kg\"\n        ]\n        \n        # Add reasoning\n        weights = decision_result['optimization_weights']\n        top_criteria = sorted(weights.items(), key=lambda x: x[1], reverse=True)[:2]\n        \n        explanation_parts.append(\"\\n**Why this route?**\")\n        \n        if best_route['rank_by_score'] == 1:\n            explanation_parts.append(\n                f\"This route offers the best balance considering your priorities: \"\n                f\"{top_criteria[0][0].replace('_', ' ')} ({top_criteria[0][1]*100:.0f}% weight) and \"\n                f\"{top_criteria[1][0].replace('_', ' ')} ({top_criteria[1][1]*100:.0f}% weight).\"\n            )\n        \n        return \"\\n\".join(explanation_parts)\n    \n    def update_optimization_weights(self, new_weights: Dict) -> None:\n        \"\"\"\n        Update optimization criteria weights\n        \n        Args:\n            new_weights: New weight values\n        \"\"\"\n        # Validate weights\n        valid_criteria = set(self.optimization_weights.keys())\n        provided_criteria = set(new_weights.keys())\n        \n        if not provided_criteria.issubset(valid_criteria):\n            invalid = provided_criteria - valid_criteria\n            raise ValueError(f\"Invalid criteria: {invalid}. Valid: {valid_criteria}\")\n        \n        # Update weights\n        for criterion, weight in new_weights.items():\n            if 0 <= weight <= 1:\n                self.optimization_weights[criterion] = weight\n            else:\n                raise ValueError(f\"Weight for {criterion} must be between 0 and 1\")\n        \n        # Normalize to sum to 1\n        total = sum(self.optimization_weights.values())\n        if total > 0:\n            for criterion in self.optimization_weights:\n                self.optimization_weights[criterion] /= total"