# Test src modules functionality\n\nimport unittest\nimport pandas as pd\nimport numpy as np\nimport sys\nimport os\nfrom unittest.mock import Mock, patch, MagicMock\n\n# Add parent directory to path\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom src.perception_module import PerceptionModule\nfrom src.reasoning_module import ReasoningModule\nfrom src.decision_module import DecisionModule\nfrom src.action_module import ActionModule\nfrom src.traffic_agent import TrafficAdvisoryAgent\nfrom utils.data_generator import TrafficDataGenerator\n\nclass TestPerceptionModule(unittest.TestCase):\n    \"\"\"Test cases for perception module\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.perception = PerceptionModule()\n        \n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(20)\n        self.test_data = generator.generate_traffic_patterns(routes, days=7)\n    \n    def test_data_loading(self):\n        \"\"\"Test traffic data loading\"\"\"\n        loaded_data = self.perception.load_traffic_data(self.test_data)\n        \n        # Should be the same data\n        self.assertEqual(len(loaded_data), len(self.test_data))\n        self.assertListEqual(list(loaded_data.columns), list(self.test_data.columns))\n    \n    def test_user_input_parsing(self):\n        \"\"\"Test user input parsing\"\"\"\n        user_input = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'preferred_time': '08:00',\n            'day_of_week': 1,\n            'preferences': ['time_efficient', 'eco_friendly']\n        }\n        \n        parsed_input = self.perception.parse_user_input(user_input)\n        \n        # Should have all required fields\n        required_fields = ['source', 'destination', 'hour', 'day_of_week', 'preferences']\n        for field in required_fields:\n            self.assertIn(field, parsed_input)\n        \n        # Time should be converted to hour\n        self.assertEqual(parsed_input['hour'], 8)\n    \n    def test_data_preprocessing(self):\n        \"\"\"Test data preprocessing\"\"\"\n        preprocessed = self.perception.preprocess_traffic_data(self.test_data)\n        \n        # Should have additional features\n        expected_features = ['is_weekend', 'is_rush_hour', 'time_of_day']\n        for feature in expected_features:\n            self.assertIn(feature, preprocessed.columns)\n        \n        # Should not have null values in critical columns\n        critical_columns = ['source', 'destination', 'distance_km', 'congestion_score']\n        for col in critical_columns:\n            if col in preprocessed.columns:\n                self.assertFalse(preprocessed[col].isnull().any())\n    \n    def test_data_validation(self):\n        \"\"\"Test data validation\"\"\"\n        # Test with valid data\n        validation_result = self.perception.validate_data(self.test_data)\n        self.assertTrue(validation_result['is_valid'])\n        self.assertEqual(len(validation_result['errors']), 0)\n        \n        # Test with invalid data\n        invalid_data = self.test_data.copy()\n        invalid_data.loc[0, 'congestion_score'] = 2.0  # Invalid score > 1\n        \n        validation_result = self.perception.validate_data(invalid_data)\n        self.assertFalse(validation_result['is_valid'])\n        self.assertGreater(len(validation_result['errors']), 0)\n    \n    def test_data_quality_check(self):\n        \"\"\"Test data quality assessment\"\"\"\n        quality_report = self.perception.assess_data_quality(self.test_data)\n        \n        # Should have quality metrics\n        expected_metrics = ['completeness', 'consistency', 'accuracy', 'timeliness']\n        for metric in expected_metrics:\n            self.assertIn(metric, quality_report)\n            self.assertGreaterEqual(quality_report[metric], 0)\n            self.assertLessEqual(quality_report[metric], 100)\n\nclass TestReasoningModule(unittest.TestCase):\n    \"\"\"Test cases for reasoning module\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(25)\n        self.test_data = generator.generate_traffic_patterns(routes, days=10)\n        \n        self.reasoning = ReasoningModule()\n        self.reasoning.load_traffic_data(self.test_data)\n    \n    def test_congestion_pattern_analysis(self):\n        \"\"\"Test congestion pattern analysis\"\"\"\n        patterns = self.reasoning.analyze_congestion_patterns()\n        \n        # Should have pattern analysis\n        expected_keys = ['peak_hours', 'congestion_hotspots', 'weekly_patterns', 'route_insights']\n        for key in expected_keys:\n            self.assertIn(key, patterns)\n        \n        # Peak hours should be valid hours\n        peak_hours = patterns['peak_hours']\n        for hour in peak_hours:\n            self.assertGreaterEqual(hour, 0)\n            self.assertLessEqual(hour, 23)\n    \n    def test_traffic_prediction(self):\n        \"\"\"Test traffic prediction\"\"\"\n        prediction_request = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'hour': 8,\n            'day_of_week': 1\n        }\n        \n        prediction = self.reasoning.predict_congestion(prediction_request)\n        \n        # Should have prediction results\n        self.assertIn('congestion_score', prediction)\n        self.assertIn('confidence', prediction)\n        self.assertIn('traffic_level', prediction)\n        \n        # Validate ranges\n        self.assertGreaterEqual(prediction['congestion_score'], 0.0)\n        self.assertLessEqual(prediction['congestion_score'], 1.0)\n        self.assertGreaterEqual(prediction['confidence'], 0.0)\n        self.assertLessEqual(prediction['confidence'], 1.0)\n    \n    def test_peak_hour_identification(self):\n        \"\"\"Test peak hour identification\"\"\"\n        peak_hours = self.reasoning.identify_peak_hours()\n        \n        # Should identify reasonable peak hours\n        self.assertIsInstance(peak_hours, dict)\n        self.assertIn('morning_peak', peak_hours)\n        self.assertIn('evening_peak', peak_hours)\n        \n        # Peak hours should be in reasonable range\n        morning_peak = peak_hours['morning_peak']\n        evening_peak = peak_hours['evening_peak']\n        \n        self.assertGreaterEqual(morning_peak, 6)\n        self.assertLessEqual(morning_peak, 10)\n        self.assertGreaterEqual(evening_peak, 16)\n        self.assertLessEqual(evening_peak, 20)\n    \n    def test_route_bottleneck_analysis(self):\n        \"\"\"Test bottleneck analysis\"\"\"\n        bottlenecks = self.reasoning.analyze_bottlenecks()\n        \n        self.assertIsInstance(bottlenecks, list)\n        \n        # Each bottleneck should have required info\n        for bottleneck in bottlenecks[:3]:  # Test first 3\n            self.assertIn('location', bottleneck)\n            self.assertIn('severity', bottleneck)\n            self.assertIn('peak_hours', bottleneck)\n            self.assertIn('alternative_routes', bottleneck)\n    \n    def test_insight_generation(self):\n        \"\"\"Test insight generation\"\"\"\n        insights = self.reasoning.generate_insights()\n        \n        self.assertIsInstance(insights, list)\n        self.assertGreater(len(insights), 0)\n        \n        # Should have actionable insights\n        insight_text = ' '.join(insights)\n        self.assertGreater(len(insight_text), 50)  # Reasonable content length\n\nclass TestDecisionModule(unittest.TestCase):\n    \"\"\"Test cases for decision module\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(20)\n        self.test_data = generator.generate_traffic_patterns(routes, days=8)\n        \n        self.decision = DecisionModule()\n        self.decision.load_traffic_data(self.test_data)\n    \n    def test_travel_time_optimization(self):\n        \"\"\"Test travel time optimization\"\"\"\n        request = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'preferred_hour': 8,\n            'day_of_week': 1,\n            'preferences': ['time_efficient']\n        }\n        \n        optimal_time = self.decision.find_best_travel_time(request)\n        \n        # Should have optimization results\n        self.assertIn('recommended_hour', optimal_time)\n        self.assertIn('estimated_travel_time', optimal_time)\n        self.assertIn('congestion_level', optimal_time)\n        self.assertIn('confidence', optimal_time)\n        \n        # Recommended hour should be valid\n        self.assertGreaterEqual(optimal_time['recommended_hour'], 0)\n        self.assertLessEqual(optimal_time['recommended_hour'], 23)\n    \n    def test_route_comparison(self):\n        \"\"\"Test route alternative comparison\"\"\"\n        routes = [\n            {'route_id': 'route1', 'distance_km': 10, 'estimated_time': 25},\n            {'route_id': 'route2', 'distance_km': 12, 'estimated_time': 20},\n            {'route_id': 'route3', 'distance_km': 8, 'estimated_time': 30}\n        ]\n        \n        preferences = ['time_efficient', 'fuel_efficient']\n        comparison = self.decision.compare_route_alternatives(routes, preferences)\n        \n        self.assertIn('ranked_routes', comparison)\n        self.assertIn('recommendation_reason', comparison)\n        \n        # Should be ranked\n        ranked_routes = comparison['ranked_routes']\n        self.assertEqual(len(ranked_routes), len(routes))\n        \n        # Each route should have a score\n        for route in ranked_routes:\n            self.assertIn('overall_score', route)\n    \n    def test_multi_criteria_optimization(self):\n        \"\"\"Test multi-criteria optimization\"\"\"\n        criteria = {\n            'time_weight': 0.4,\n            'fuel_weight': 0.3,\n            'environmental_weight': 0.3\n        }\n        \n        request = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'preferred_hour': 8,\n            'day_of_week': 1\n        }\n        \n        optimization = self.decision.optimize_multi_criteria(request, criteria)\n        \n        # Should have optimization results\n        self.assertIn('recommended_route', optimization)\n        self.assertIn('optimization_scores', optimization)\n        self.assertIn('trade_offs', optimization)\n        \n        # Scores should be within valid range\n        scores = optimization['optimization_scores']\n        for score in scores.values():\n            self.assertGreaterEqual(score, 0)\n            self.assertLessEqual(score, 100)\n    \n    def test_preference_weighting(self):\n        \"\"\"Test preference weighting\"\"\"\n        preferences = ['time_efficient', 'eco_friendly', 'cost_effective']\n        weights = self.decision.calculate_preference_weights(preferences)\n        \n        # Should have weights for all preferences\n        self.assertEqual(len(weights), len(preferences))\n        \n        # Weights should sum to approximately 1.0\n        total_weight = sum(weights.values())\n        self.assertAlmostEqual(total_weight, 1.0, places=2)\n        \n        # All weights should be positive\n        for weight in weights.values():\n            self.assertGreater(weight, 0)\n\nclass TestActionModule(unittest.TestCase):\n    \"\"\"Test cases for action module\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.action = ActionModule()\n    \n    def test_recommendation_generation(self):\n        \"\"\"Test recommendation generation\"\"\"\n        decision_output = {\n            'recommended_route': {\n                'source': 'Downtown',\n                'destination': 'Airport',\n                'distance_km': 15,\n                'travel_time_min': 25,\n                'route_type': 'direct'\n            },\n            'recommended_time': {\n                'hour': 7,\n                'travel_time_min': 20,\n                'congestion_level': 'low'\n            },\n            'alternatives': [\n                {'route_type': 'scenic', 'travel_time_min': 30},\n                {'route_type': 'highway', 'travel_time_min': 22}\n            ]\n        }\n        \n        recommendations = self.action.generate_recommendations(decision_output)\n        \n        # Should have structured recommendations\n        self.assertIn('primary_recommendation', recommendations)\n        self.assertIn('alternatives', recommendations)\n        self.assertIn('insights', recommendations)\n        \n        # Primary recommendation should have key details\n        primary = recommendations['primary_recommendation']\n        self.assertIn('route', primary)\n        self.assertIn('timing', primary)\n        self.assertIn('justification', primary)\n    \n    def test_display_formatting(self):\n        \"\"\"Test display formatting\"\"\"\n        recommendations = {\n            'primary_recommendation': {\n                'route': {\n                    'source': 'Downtown',\n                    'destination': 'Airport',\n                    'distance_km': 15,\n                    'travel_time_min': 25\n                },\n                'timing': {'hour': 7, 'congestion_level': 'low'}\n            },\n            'alternatives': [],\n            'insights': ['Traffic is lightest at 7 AM']\n        }\n        \n        formatted = self.action.format_for_display(recommendations)\n        \n        # Should have formatted sections\n        self.assertIn('summary', formatted)\n        self.assertIn('detailed_route', formatted)\n        self.assertIn('timing_advice', formatted)\n        self.assertIn('insights', formatted)\n        \n        # Should be readable text\n        summary = formatted['summary']\n        self.assertGreater(len(summary), 20)  # Reasonable summary length\n    \n    def test_export_functionality(self):\n        \"\"\"Test recommendation export\"\"\"\n        recommendations = {\n            'primary_recommendation': {\n                'route': {'source': 'Downtown', 'destination': 'Airport'},\n                'timing': {'hour': 7}\n            },\n            'alternatives': [],\n            'insights': ['Test insight']\n        }\n        \n        # Test JSON export\n        json_export = self.action.export_recommendations(recommendations, format='json')\n        self.assertIn('timestamp', json_export)\n        self.assertIn('recommendations', json_export)\n        \n        # Test CSV export\n        csv_export = self.action.export_recommendations(recommendations, format='csv')\n        self.assertIsInstance(csv_export, str)\n        self.assertIn('Route', csv_export)  # Should have header\n    \n    def test_alert_generation(self):\n        \"\"\"Test alert generation for critical conditions\"\"\"\n        traffic_conditions = {\n            'congestion_level': 'high',\n            'incidents': ['accident on main route'],\n            'weather_impact': 'moderate'\n        }\n        \n        alerts = self.action.generate_alerts(traffic_conditions)\n        \n        self.assertIsInstance(alerts, list)\n        \n        # Should have relevant alerts for high congestion\n        alert_text = ' '.join(alerts)\n        self.assertTrue(any(word in alert_text.lower() for word in ['congestion', 'delay', 'alternative']))\n\nclass TestTrafficAgent(unittest.TestCase):\n    \"\"\"Test cases for the main traffic agent\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.agent = TrafficAdvisoryAgent()\n        \n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(15)\n        self.test_data = generator.generate_traffic_patterns(routes, days=5)\n    \n    def test_agent_initialization(self):\n        \"\"\"Test agent initialization\"\"\"\n        self.agent.initialize(self.test_data)\n        \n        # Should have initialized all modules\n        self.assertIsNotNone(self.agent.perception)\n        self.assertIsNotNone(self.agent.reasoning)\n        self.assertIsNotNone(self.agent.decision)\n        self.assertIsNotNone(self.agent.action)\n        \n        # Should be ready to process requests\n        self.assertTrue(self.agent.is_initialized)\n    \n    def test_request_processing(self):\n        \"\"\"Test end-to-end request processing\"\"\"\n        self.agent.initialize(self.test_data)\n        \n        user_request = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'preferred_time': '08:00',\n            'day_of_week': 1,\n            'preferences': ['time_efficient']\n        }\n        \n        response = self.agent.process_request(user_request)\n        \n        # Should have complete response\n        self.assertIn('recommendations', response)\n        self.assertIn('processing_time', response)\n        self.assertIn('confidence', response)\n        \n        # Recommendations should be structured\n        recommendations = response['recommendations']\n        self.assertIn('primary_recommendation', recommendations)\n    \n    def test_batch_processing(self):\n        \"\"\"Test batch request processing\"\"\"\n        self.agent.initialize(self.test_data)\n        \n        requests = [\n            {\n                'source': 'Downtown', 'destination': 'Airport',\n                'preferred_time': '08:00', 'day_of_week': 1\n            },\n            {\n                'source': 'Mall', 'destination': 'University',\n                'preferred_time': '17:00', 'day_of_week': 2\n            }\n        ]\n        \n        responses = self.agent.process_batch_requests(requests)\n        \n        self.assertEqual(len(responses), len(requests))\n        \n        # Each response should be valid\n        for response in responses:\n            self.assertIn('recommendations', response)\n            self.assertIn('processing_time', response)\n    \n    def test_agent_state_management(self):\n        \"\"\"Test agent state management\"\"\"\n        # Test state saving\n        self.agent.initialize(self.test_data)\n        state = self.agent.get_agent_state()\n        \n        self.assertIn('is_initialized', state)\n        self.assertIn('data_loaded', state)\n        self.assertIn('last_update', state)\n        \n        # Test state restoration\n        new_agent = TrafficAdvisoryAgent()\n        new_agent.restore_agent_state(state, self.test_data)\n        \n        self.assertTrue(new_agent.is_initialized)\n    \n    def test_performance_monitoring(self):\n        \"\"\"Test performance monitoring\"\"\"\n        self.agent.initialize(self.test_data)\n        \n        # Process several requests to generate metrics\n        for i in range(3):\n            request = {\n                'source': 'Downtown',\n                'destination': 'Airport',\n                'preferred_time': f'{8+i:02d}:00',\n                'day_of_week': 1\n            }\n            self.agent.process_request(request)\n        \n        # Get performance metrics\n        metrics = self.agent.get_performance_metrics()\n        \n        self.assertIn('total_requests', metrics)\n        self.assertIn('average_response_time', metrics)\n        self.assertIn('success_rate', metrics)\n        \n        # Should have processed 3 requests\n        self.assertEqual(metrics['total_requests'], 3)\n        self.assertGreaterEqual(metrics['success_rate'], 0.0)\n        self.assertLessEqual(metrics['success_rate'], 1.0)\n\nclass TestModuleIntegration(unittest.TestCase):\n    \"\"\"Test integration between src modules\"\"\"\n    \n    def test_perception_reasoning_flow(self):\n        \"\"\"Test data flow from perception to reasoning\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(10)\n        test_data = generator.generate_traffic_patterns(routes, days=5)\n        \n        # Initialize modules\n        perception = PerceptionModule()\n        reasoning = ReasoningModule()\n        \n        # Test data flow\n        processed_data = perception.preprocess_traffic_data(test_data)\n        reasoning.load_traffic_data(processed_data)\n        \n        # Reasoning should be able to analyze the data\n        patterns = reasoning.analyze_congestion_patterns()\n        self.assertIn('peak_hours', patterns)\n    \n    def test_reasoning_decision_flow(self):\n        \"\"\"Test data flow from reasoning to decision\"\"\"\n        # Generate test data\n        generator = TrafficDataGenerator()\n        routes = generator.generate_routes(10)\n        test_data = generator.generate_traffic_patterns(routes, days=5)\n        \n        # Initialize modules\n        reasoning = ReasoningModule()\n        decision = DecisionModule()\n        \n        reasoning.load_traffic_data(test_data)\n        decision.load_traffic_data(test_data)\n        \n        # Get reasoning insights\n        insights = reasoning.generate_insights()\n        \n        # Decision should be able to use insights\n        request = {\n            'source': 'Downtown',\n            'destination': 'Airport',\n            'preferred_hour': 8,\n            'day_of_week': 1,\n            'preferences': ['time_efficient']\n        }\n        \n        decision_result = decision.find_best_travel_time(request)\n        self.assertIn('recommended_hour', decision_result)\n    \n    def test_decision_action_flow(self):\n        \"\"\"Test data flow from decision to action\"\"\"\n        # Mock decision output\n        decision_output = {\n            'recommended_route': {\n                'source': 'Downtown',\n                'destination': 'Airport',\n                'distance_km': 15,\n                'travel_time_min': 25\n            },\n            'recommended_time': {\n                'hour': 7,\n                'congestion_level': 'low'\n            },\n            'alternatives': []\n        }\n        \n        # Initialize action module\n        action = ActionModule()\n        \n        # Generate recommendations\n        recommendations = action.generate_recommendations(decision_output)\n        \n        # Should have actionable recommendations\n        self.assertIn('primary_recommendation', recommendations)\n        \n        # Format for display\n        formatted = action.format_for_display(recommendations)\n        self.assertIn('summary', formatted)\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)"