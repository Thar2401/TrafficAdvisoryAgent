# Main Traffic Advisory Agent - Orchestrates the agentic workflow

import pandas as pd
from typing import Dict, List, Optional
from datetime import datetime
import os

# Import agent modules
from .perception_module import PerceptionModule
from .reasoning_module import ReasoningModule
from .decision_module import DecisionModule
from .action_module import ActionModule

# Import models
from models.traffic_predictor import TrafficPredictor
from models.route_optimizer import RouteOptimizer
from models.sustainability_calculator import SustainabilityCalculator

# Import utilities
from utils.config import Config
from utils.validators import InputValidator

class TrafficAdvisoryAgent:
    """
    AI-Based Traffic Advisory Agent for Sustainable Urban Mobility
    Implements the complete agentic workflow: Perception â†’ Reasoning â†’ Decision â†’ Action
    """
    
    def __init__(self, auto_load_data: bool = True):
        """
        Initialize the Traffic Advisory Agent
        
        Args:
            auto_load_data: Whether to automatically load/generate traffic data
        """
        print(\"ğŸš¦ Initializing AI-Based Traffic Advisory Agent...\")
        
        # Initialize workflow modules\        \n        self.perception = PerceptionModule()\n        self.reasoning = ReasoningModule()\n        self.decision = DecisionModule()\n        self.action = ActionModule()\n        \n        # Initialize ML models\n        self.traffic_predictor = TrafficPredictor()\n        self.route_optimizer = None  # Will be initialized when needed\n        self.sustainability_calculator = SustainabilityCalculator()\n        \n        # Agent state\n        self.is_initialized = False\n        self.traffic_data = None\n        self.model_trained = False\n        \n        if auto_load_data:\n            self.initialize_agent()\n    \n    def initialize_agent(self) -> Dict:\n        \"\"\"\n        Initialize the agent by loading data and training models\n        \n        Returns:\n            Dict: Initialization status and metrics\n        \"\"\"\n        print(\"ğŸ“Š Loading and preprocessing traffic data...\")\n        \n        try:\n            # 1. PERCEPTION: Load and preprocess data\n            self.traffic_data = self.perception.load_traffic_data()\n            processed_data = self.perception.preprocess_traffic_data()\n            \n            print(f\"âœ… Loaded {len(self.traffic_data)} traffic records\")\n            \n            # 2. Train traffic prediction model\n            print(\"ğŸ¤– Training traffic prediction model...\")\n            training_metrics = self.traffic_predictor.train(processed_data)\n            self.model_trained = True\n            \n            print(f\"âœ… Model trained with RÂ² score: {training_metrics['test_r2']:.3f}\")\n            \n            # 3. Initialize route optimizer with data\n            self.route_optimizer = RouteOptimizer(processed_data)\n            \n            # 4. Validate data quality\n            quality_report = self.perception.validate_data_quality()\n            \n            self.is_initialized = True\n            \n            initialization_status = {\n                'status': 'success',\n                'timestamp': datetime.now().isoformat(),\n                'data_summary': self.perception.get_traffic_summary(),\n                'model_performance': training_metrics,\n                'data_quality': quality_report,\n                'available_locations': self.perception.get_available_locations()\n            }\n            \n            print(\"ğŸ¯ Agent initialization complete!\")\n            return initialization_status\n            \n        except Exception as e:\n            error_status = {\n                'status': 'error',\n                'timestamp': datetime.now().isoformat(),\n                'error_message': str(e),\n                'initialization_failed': True\n            }\n            print(f\"âŒ Agent initialization failed: {e}\")\n            return error_status\n    \n    def process_request(self, source: str, destination: str, \n                       preferred_time: str = None,\n                       user_preferences: Dict = None) -> Dict:\n        \"\"\"\n        Main method to process traffic advisory requests\n        Implements the complete agentic workflow\n        \n        Args:\n            source: Starting location\n            destination: Destination location\n            preferred_time: Preferred departure time (optional)\n            user_preferences: User preference weights for optimization\n            \n        Returns:\n            Dict: Complete traffic advisory recommendations\n        \"\"\"\n        if not self.is_initialized:\n            return {\n                'error': 'Agent not initialized. Call initialize_agent() first.',\n                'status': 'not_ready'\n            }\n        \n        try:\n            print(f\"\\nğŸ¯ Processing request: {source} â†’ {destination}\")\n            if preferred_time:\n                print(f\"   Preferred time: {preferred_time}\")\n            \n            # STEP 1: PERCEPTION - Parse and validate input\n            print(\"ğŸ” PERCEPTION: Processing input...\")\n            user_input = self.perception.parse_user_input(\n                source, destination, preferred_time\n            )\n            \n            # STEP 2: REASONING - Analyze traffic patterns and predict congestion\n            print(\"ğŸ§  REASONING: Analyzing traffic patterns...\")\n            \n            # Analyze historical patterns\n            congestion_patterns = self.reasoning.analyze_congestion_patterns(self.traffic_data)\n            peak_hours = self.reasoning.identify_peak_hours(self.traffic_data)\n            \n            # Predict congestion for the specific request\n            congestion_forecast = self.reasoning.predict_congestion(\n                user_input, self.traffic_data, self.traffic_predictor\n            )\n            \n            # Generate travel insights\n            travel_patterns = self.reasoning.calculate_travel_patterns(self.traffic_data)\n            \n            # STEP 3: DECISION-MAKING - Optimize routes and times\n            print(\"âš–ï¸ DECISION: Optimizing routes and timing...\")\n            \n            # Find optimal travel time\n            optimal_time = self.decision.find_best_travel_time(\n                congestion_forecast, time_flexibility_hours=3\n            )\n            \n            # Find alternative routes\n            alternative_routes = self.decision.find_alternative_routes(\n                source, destination, self.route_optimizer\n            )\n            \n            # Evaluate routes at different times\n            route_evaluations = []\n            for route in alternative_routes:\n                for time_option in optimal_time['all_options'][:5]:  # Top 5 time options\n                    evaluation = self.route_optimizer.evaluate_route_at_time(\n                        route, time_option['hour'], user_input['current_day_of_week'],\n                        self.traffic_predictor\n                    )\n                    route_evaluations.append(evaluation)\n            \n            # Multi-criteria optimization\n            optimization_result = self.decision.optimize_multi_criteria(\n                route_evaluations, user_preferences\n            )\n            \n            # STEP 4: ACTION - Generate recommendations\n            print(\"ğŸš€ ACTION: Generating recommendations...\")\n            \n            # Calculate sustainability impact\n            sustainability_analysis = self.sustainability_calculator.calculate_route_alternatives_sustainability(\n                optimization_result['ranked_routes'][:5]\n            )\n            \n            # Generate comprehensive recommendations\n            recommendations = self.action.generate_recommendations(\n                optimization_result, user_input, sustainability_analysis\n            )\n            \n            # Add analysis data for transparency\n            recommendations['analysis_details'] = {\n                'congestion_patterns': congestion_patterns,\n                'peak_hours': peak_hours,\n                'congestion_forecast': congestion_forecast,\n                'travel_patterns': travel_patterns,\n                'optimization_result': optimization_result,\n                'sustainability_analysis': sustainability_analysis\n            }\n            \n            # Generate insights\n            insights = self.reasoning.generate_insights({\n                'peak_analysis': peak_hours,\n                'congestion_patterns': congestion_patterns,\n                'travel_patterns': travel_patterns\n            })\n            recommendations['expert_insights'] = insights\n            \n            print(\"âœ… Request processed successfully!\")\n            return recommendations\n            \n        except ValueError as e:\n            # Input validation errors\n            return {\n                'error': f\"Input validation failed: {str(e)}\",\n                'status': 'invalid_input',\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            # Unexpected errors\n            return {\n                'error': f\"Processing failed: {str(e)}\",\n                'status': 'processing_error',\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_traffic_insights(self, location: str = None, \n                           hour: int = None) -> Dict:\n        \"\"\"\n        Get general traffic insights for a location or time\n        \n        Args:\n            location: Specific location (optional)\n            hour: Specific hour (optional)\n            \n        Returns:\n            Dict: Traffic insights and patterns\n        \"\"\"\n        if not self.is_initialized:\n            return {'error': 'Agent not initialized'}\n        \n        insights = {}\n        \n        # Location-specific insights\n        if location:\n            location_data = self.traffic_data[\n                (self.traffic_data['source'] == location) |\n                (self.traffic_data['destination'] == location)\n            ]\n            \n            if len(location_data) > 0:\n                insights['location_analysis'] = {\n                    'average_congestion': location_data['congestion_score'].mean(),\n                    'peak_congestion': location_data['congestion_score'].max(),\n                    'best_hours': location_data.groupby('hour')['congestion_score'].mean().nsmallest(3).index.tolist(),\n                    'worst_hours': location_data.groupby('hour')['congestion_score'].mean().nlargest(3).index.tolist()\n                }\n        \n        # Time-specific insights\n        if hour is not None:\n            hour_data = self.traffic_data[self.traffic_data['hour'] == hour]\n            \n            if len(hour_data) > 0:\n                insights['hour_analysis'] = {\n                    'average_congestion': hour_data['congestion_score'].mean(),\n                    'typical_speed': hour_data['avg_speed_kmh'].mean(),\n                    'affected_routes': len(hour_data),\n                    'traffic_level_distribution': hour_data['traffic_level'].value_counts().to_dict()\n                }\n        \n        # General patterns\n        insights['general_patterns'] = self.reasoning.analyze_congestion_patterns(self.traffic_data)\n        insights['peak_hours'] = self.reasoning.identify_peak_hours(self.traffic_data)\n        \n        return insights\n    \n    def update_preferences(self, new_preferences: Dict) -> Dict:\n        \"\"\"\n        Update user optimization preferences\n        \n        Args:\n            new_preferences: New preference weights\n            \n        Returns:\n            Dict: Update status\n        \"\"\"\n        try:\n            self.decision.update_optimization_weights(new_preferences)\n            \n            return {\n                'status': 'success',\n                'message': 'Preferences updated successfully',\n                'current_weights': self.decision.optimization_weights,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            return {\n                'status': 'error',\n                'message': f'Failed to update preferences: {str(e)}',\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_sustainability_report(self, route_data: Dict) -> Dict:\n        \"\"\"\n        Generate detailed sustainability report for a route\n        \n        Args:\n            route_data: Route information\n            \n        Returns:\n            Dict: Sustainability analysis\n        \"\"\"\n        distance_km = route_data.get('distance_km', 10)\n        \n        # Compare transportation modes\n        mode_comparison = self.sustainability_calculator.compare_transportation_modes(distance_km)\n        \n        # Generate recommendations\n        current_co2 = route_data.get('co2_emission_kg', distance_km * 0.18)\n        recommendations = self.sustainability_calculator.generate_sustainability_recommendations(\n            distance_km, current_co2\n        )\n        \n        return {\n            'route_distance_km': distance_km,\n            'current_impact': route_data,\n            'transportation_mode_comparison': mode_comparison,\n            'recommendations': recommendations,\n            'generated_at': datetime.now().isoformat()\n        }\n    \n    def export_analysis(self, analysis_result: Dict, \n                       filepath: str = None) -> str:\n        \"\"\"\n        Export analysis results to file\n        \n        Args:\n            analysis_result: Analysis results to export\n            filepath: Optional file path\n            \n        Returns:\n            str: Path to exported file\n        \"\"\"\n        return self.action.export_recommendations(analysis_result, filepath)\n    \n    def get_agent_status(self) -> Dict:\n        \"\"\"\n        Get current agent status and capabilities\n        \n        Returns:\n            Dict: Agent status information\n        \"\"\"\n        status = {\n            'agent_initialized': self.is_initialized,\n            'model_trained': self.model_trained,\n            'data_loaded': self.traffic_data is not None,\n            'available_locations': self.perception.get_available_locations() if self.is_initialized else [],\n            'capabilities': {\n                'traffic_prediction': self.model_trained,\n                'route_optimization': self.route_optimizer is not None,\n                'sustainability_analysis': True,\n                'multi_criteria_optimization': True\n            },\n            'last_update': datetime.now().isoformat()\n        }\n        \n        if self.is_initialized:\n            status['data_summary'] = self.perception.get_traffic_summary()\n            \n        if self.model_trained:\n            status['model_performance'] = {\n                'feature_importance': self.traffic_predictor.get_feature_importance()\n            }\n        \n        return status\n    \n    def __str__(self) -> str:\n        \"\"\"\n        String representation of the agent\n        \n        Returns:\n            str: Agent description\n        \"\"\"\n        return (\n            f\"ğŸš¦ AI-Based Traffic Advisory Agent\\n\"\n            f\"ğŸ“ Status: {'Initialized' if self.is_initialized else 'Not Initialized'}\\n\"\n            f\"ğŸ¤– Model: {'Trained' if self.model_trained else 'Not Trained'}\\n\"\n            f\"ğŸ“Š Data: {len(self.traffic_data) if self.traffic_data is not None else 0} records\\n\"\n            f\"ğŸ¯ SDG Alignment: SDG 11 - Sustainable Cities and Communities\"\n        )"