# Perception module - Data ingestion and preprocessing

import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import os

from utils.config import Config
from utils.validators import InputValidator

class PerceptionModule:
    """
    Handles data ingestion, preprocessing, and user input parsing
    This is the PERCEPTION component of the agentic workflow
    """
    
    def __init__(self):
        """Initialize perception module"""
        self.traffic_data = None
        self.data_loaded = False
        self.last_update = None
    
    def load_traffic_data(self, data_path: str = None) -> pd.DataFrame:
        """
        Load traffic data from file or generate if not exists
        
        Args:
            data_path: Path to traffic data file
            
        Returns:
            pd.DataFrame: Loaded traffic data
        """
        if data_path is None:
            # Try to find existing data in simulated directory
            simulated_dir = Config.SIMULATED_DATA_DIR
            if os.path.exists(simulated_dir):\n                csv_files = [f for f in os.listdir(simulated_dir) if f.endswith('.csv')]\n                if csv_files:\n                    # Use most recent file\n                    csv_files.sort(reverse=True)\n                    data_path = os.path.join(simulated_dir, csv_files[0])\n        \n        if data_path and os.path.exists(data_path):\n            print(f\"Loading traffic data from {data_path}\")\n            self.traffic_data = pd.read_csv(data_path)\n        else:\n            print(\"No traffic data found. Generating new dataset...\")\n            from utils.data_generator import TrafficDataGenerator\n            generator = TrafficDataGenerator()\n            self.traffic_data = generator.generate_complete_dataset(num_routes=50, days=30)\n            \n            # Save generated data\n            os.makedirs(Config.SIMULATED_DATA_DIR, exist_ok=True)\n            save_path = generator.save_dataset(self.traffic_data, \"generated_traffic_data.csv\")\n            print(f\"Generated and saved traffic data to {save_path}\")\n        \n        self.data_loaded = True\n        self.last_update = datetime.now()\n        \n        return self.traffic_data\n    \n    def parse_user_input(self, source: str, destination: str, \n                        preferred_time: str = None) -> Dict:\n        \"\"\"\n        Parse and validate user input for route planning\n        \n        Args:\n            source: Source location\n            destination: Destination location  \n            preferred_time: Preferred departure time (optional)\n            \n        Returns:\n            Dict: Parsed and validated input data\n        \"\"\"\n        # Validate and sanitize inputs\n        source_clean = InputValidator.sanitize_location(source)\n        destination_clean = InputValidator.sanitize_location(destination)\n        \n        # Validate locations\n        source_valid = InputValidator.validate_location(source_clean)\n        destination_valid = InputValidator.validate_location(destination_clean)\n        \n        if not source_valid:\n            raise ValueError(f\"Invalid source location: {source}\")\n        if not destination_valid:\n            raise ValueError(f\"Invalid destination location: {destination}\")\n        if source_clean == destination_clean:\n            raise ValueError(\"Source and destination cannot be the same\")\n        \n        # Parse time preference\n        preferred_hour = None\n        if preferred_time:\n            preferred_hour = InputValidator.validate_time_preference(preferred_time)\n            if preferred_hour is None:\n                raise ValueError(f\"Invalid time format: {preferred_time}. Use HH:MM or HH format.\")\n        \n        # Get current time info for context\n        now = datetime.now()\n        current_hour = now.hour\n        current_day_of_week = now.weekday()\n        \n        parsed_input = {\n            'source': source_clean,\n            'destination': destination_clean,\n            'preferred_time_str': preferred_time,\n            'preferred_hour': preferred_hour,\n            'current_hour': current_hour,\n            'current_day_of_week': current_day_of_week,\n            'timestamp': now,\n            'is_valid': True\n        }\n        \n        return parsed_input\n    \n    def preprocess_traffic_data(self, data: pd.DataFrame = None) -> pd.DataFrame:\n        \"\"\"\n        Clean and preprocess traffic data for analysis\n        \n        Args:\n            data: Raw traffic data, uses loaded data if None\n            \n        Returns:\n            pd.DataFrame: Preprocessed traffic data\n        \"\"\"\n        if data is None:\n            if not self.data_loaded:\n                raise ValueError(\"No traffic data loaded. Call load_traffic_data() first.\")\n            data = self.traffic_data\n        \n        # Create a copy for processing\n        processed_data = data.copy()\n        \n        # Handle missing values\n        processed_data = processed_data.dropna()\n        \n        # Ensure data types are correct\n        numeric_columns = [\n            'distance_km', 'hour', 'day_of_week', 'congestion_score',\n            'avg_speed_kmh', 'travel_time_min', 'fuel_consumption_l', 'co2_emission_kg'\n        ]\n        \n        for col in numeric_columns:\n            if col in processed_data.columns:\n                processed_data[col] = pd.to_numeric(processed_data[col], errors='coerce')\n        \n        # Remove any rows with invalid numeric data\n        processed_data = processed_data.dropna(subset=numeric_columns)\n        \n        # Validate ranges\n        processed_data = processed_data[\n            (processed_data['hour'] >= 0) & (processed_data['hour'] <= 23) &\n            (processed_data['day_of_week'] >= 0) & (processed_data['day_of_week'] <= 6) &\n            (processed_data['congestion_score'] >= 0) & (processed_data['congestion_score'] <= 1) &\n            (processed_data['distance_km'] > 0) &\n            (processed_data['avg_speed_kmh'] > 0) &\n            (processed_data['travel_time_min'] > 0)\n        ]\n        \n        # Add derived features\n        processed_data['is_weekend'] = processed_data['day_of_week'].isin([5, 6])\n        processed_data['is_rush_hour'] = (\n            (processed_data['hour'].between(7, 9)) | \n            (processed_data['hour'].between(17, 19))\n        )\n        \n        # Add time period categories\n        def get_time_period(hour):\n            if 6 <= hour <= 11:\n                return 'morning'\n            elif 12 <= hour <= 17:\n                return 'afternoon'\n            elif 18 <= hour <= 22:\n                return 'evening'\n            else:\n                return 'night'\n        \n        processed_data['time_period'] = processed_data['hour'].apply(get_time_period)\n        \n        print(f\"Preprocessed {len(processed_data)} traffic records\")\n        return processed_data\n    \n    def get_route_historical_data(self, source: str, destination: str) -> pd.DataFrame:\n        \"\"\"\n        Get historical traffic data for a specific route\n        \n        Args:\n            source: Source location\n            destination: Destination location\n            \n        Returns:\n            pd.DataFrame: Historical data for the route\n        \"\"\"\n        if not self.data_loaded:\n            self.load_traffic_data()\n        \n        # Filter data for the specific route\n        route_data = self.traffic_data[\n            (self.traffic_data['source'] == source) &\n            (self.traffic_data['destination'] == destination)\n        ].copy()\n        \n        if len(route_data) == 0:\n            # No exact match, try to find similar routes\n            similar_routes = self.traffic_data[\n                (self.traffic_data['source'].str.contains(source, case=False, na=False)) |\n                (self.traffic_data['destination'].str.contains(destination, case=False, na=False))\n            ].copy()\n            \n            if len(similar_routes) > 0:\n                print(f\"No exact route match found. Using {len(similar_routes)} similar routes.\")\n                return similar_routes\n        \n        return route_data\n    \n    def get_traffic_summary(self) -> Dict:\n        \"\"\"\n        Get summary statistics of loaded traffic data\n        \n        Returns:\n            Dict: Summary statistics\n        \"\"\"\n        if not self.data_loaded:\n            return {\"error\": \"No traffic data loaded\"}\n        \n        summary = {\n            'total_records': len(self.traffic_data),\n            'unique_routes': self.traffic_data['route_id'].nunique(),\n            'unique_sources': self.traffic_data['source'].nunique(),\n            'unique_destinations': self.traffic_data['destination'].nunique(),\n            'date_range_days': self.traffic_data['day_of_week'].nunique(),\n            'hour_range': f\"{self.traffic_data['hour'].min()}-{self.traffic_data['hour'].max()}\",\n            'avg_congestion_score': round(self.traffic_data['congestion_score'].mean(), 3),\n            'max_congestion_score': round(self.traffic_data['congestion_score'].max(), 3),\n            'avg_travel_time_min': round(self.traffic_data['travel_time_min'].mean(), 1),\n            'avg_co2_emission_kg': round(self.traffic_data['co2_emission_kg'].mean(), 3),\n            'last_update': self.last_update.strftime(\"%Y-%m-%d %H:%M:%S\") if self.last_update else None\n        }\n        \n        return summary\n    \n    def get_available_locations(self) -> List[str]:\n        \"\"\"\n        Get list of available locations from traffic data\n        \n        Returns:\n            List[str]: List of unique locations\n        \"\"\"\n        if not self.data_loaded:\n            return Config.DEMO_LOCATIONS\n        \n        sources = set(self.traffic_data['source'].unique())\n        destinations = set(self.traffic_data['destination'].unique())\n        all_locations = sorted(list(sources.union(destinations)))\n        \n        return all_locations\n    \n    def validate_data_quality(self) -> Dict:\n        \"\"\"\n        Validate the quality of loaded traffic data\n        \n        Returns:\n            Dict: Data quality report\n        \"\"\"\n        if not self.data_loaded:\n            return {\"error\": \"No traffic data loaded\"}\n        \n        data = self.traffic_data\n        \n        # Check for missing values\n        missing_values = data.isnull().sum().to_dict()\n        missing_percentage = (data.isnull().sum() / len(data) * 100).round(2).to_dict()\n        \n        # Check for duplicates\n        duplicates = data.duplicated().sum()\n        \n        # Check value ranges\n        range_violations = {\n            'negative_distance': (data['distance_km'] <= 0).sum(),\n            'invalid_hour': ((data['hour'] < 0) | (data['hour'] > 23)).sum(),\n            'invalid_day_of_week': ((data['day_of_week'] < 0) | (data['day_of_week'] > 6)).sum(),\n            'invalid_congestion': ((data['congestion_score'] < 0) | (data['congestion_score'] > 1)).sum(),\n            'zero_travel_time': (data['travel_time_min'] <= 0).sum()\n        }\n        \n        # Calculate quality score\n        total_violations = sum(range_violations.values()) + duplicates + sum(missing_values.values())\n        quality_score = max(0, 100 - (total_violations / len(data) * 100))\n        \n        quality_report = {\n            'total_records': len(data),\n            'duplicates': duplicates,\n            'missing_values': missing_values,\n            'missing_percentage': missing_percentage,\n            'range_violations': range_violations,\n            'quality_score': round(quality_score, 2),\n            'is_acceptable': quality_score >= 80\n        }\n        \n        return quality_report"