# Action module - Recommendation generation and output formatting\n\nimport pandas as pd\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport json\n\nfrom utils.config import Config\n\nclass ActionModule:\n    \"\"\"\n    Handles recommendation generation and output formatting\n    This is the ACTION component of the agentic workflow\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize action module\"\"\"\n        self.last_recommendations = None\n        self.recommendation_history = []\n    \n    def generate_recommendations(self, optimization_result: Dict,\n                               user_input: Dict,\n                               sustainability_analysis: Dict = None) -> Dict:\n        \"\"\"\n        Generate comprehensive recommendations based on optimization results\n        \n        Args:\n            optimization_result: Results from decision module\n            user_input: Original user input\n            sustainability_analysis: Environmental impact analysis\n            \n        Returns:\n            Dict: Comprehensive recommendations\n        \"\"\"\n        recommendations = {\n            'request_info': {\n                'source': user_input['source'],\n                'destination': user_input['destination'],\n                'preferred_time': user_input.get('preferred_time_str', 'Not specified'),\n                'timestamp': datetime.now().isoformat()\n            },\n            'primary_recommendation': self._format_primary_recommendation(\n                optimization_result.get('best_overall')\n            ),\n            'alternative_options': self._format_alternative_recommendations(\n                optimization_result.get('ranked_routes', [])[:3]\n            ),\n            'time_recommendations': self._generate_time_recommendations(\n                optimization_result\n            ),\n            'sustainability_insights': self._generate_sustainability_recommendations(\n                sustainability_analysis\n            ),\n            'traffic_insights': self._generate_traffic_insights(\n                optimization_result\n            ),\n            'action_items': self._generate_action_items(\n                optimization_result, user_input\n            )\n        }\n        \n        # Store for history\n        self.last_recommendations = recommendations\n        self.recommendation_history.append({\n            'timestamp': datetime.now(),\n            'recommendations': recommendations\n        })\n        \n        return recommendations\n    \n    def _format_primary_recommendation(self, best_route: Dict) -> Dict:\n        \"\"\"\n        Format the primary route recommendation\n        \n        Args:\n            best_route: Best route from optimization\n            \n        Returns:\n            Dict: Formatted primary recommendation\n        \"\"\"\n        if not best_route:\n            return {'error': 'No optimal route found'}\n        \n        # Format time display\n        hour = best_route.get('hour', 12)\n        hour_12 = hour % 12\n        if hour_12 == 0:\n            hour_12 = 12\n        ampm = 'AM' if hour < 12 else 'PM'\n        \n        return {\n            'route_description': best_route['description'],\n            'recommended_departure': f\"{hour_12:02d}:00 {ampm}\",\n            'travel_metrics': {\n                'distance_km': best_route['distance_km'],\n                'estimated_travel_time_min': best_route['travel_time_min'],\n                'traffic_level': best_route['traffic_level'],\n                'congestion_score': best_route['congestion_score']\n            },\n            'environmental_impact': {\n                'fuel_consumption_l': best_route['fuel_consumption_l'],\n                'co2_emission_kg': best_route['co2_emission_kg']\n            },\n            'confidence_level': best_route.get('confidence', 0.8),\n            'optimization_score': best_route.get('weighted_score', 0.0),\n            'recommendation_strength': self._get_recommendation_strength(\n                best_route.get('weighted_score', 0.5)\n            )\n        }\n    \n    def _format_alternative_recommendations(self, alternatives: List[Dict]) -> List[Dict]:\n        \"\"\"\n        Format alternative route recommendations\n        \n        Args:\n            alternatives: List of alternative routes\n            \n        Returns:\n            List[Dict]: Formatted alternatives\n        \"\"\"\n        formatted_alternatives = []\n        \n        for alt in alternatives[1:]:  # Skip the first one (primary)\n            # Format time display\n            hour = alt.get('hour', 12)\n            hour_12 = hour % 12\n            if hour_12 == 0:\n                hour_12 = 12\n            ampm = 'AM' if hour < 12 else 'PM'\n            \n            formatted_alt = {\n                'route_description': alt['description'],\n                'departure_time': f\"{hour_12:02d}:00 {ampm}\",\n                'key_metrics': {\n                    'travel_time_min': alt['travel_time_min'],\n                    'traffic_level': alt['traffic_level'],\n                    'fuel_consumption_l': alt['fuel_consumption_l']\n                },\n                'comparison_to_primary': self._compare_to_primary(\n                    alt, alternatives[0] if alternatives else None\n                ),\n                'best_for': self._identify_best_aspect(alt)\n            }\n            \n            formatted_alternatives.append(formatted_alt)\n        \n        return formatted_alternatives\n    \n    def _compare_to_primary(self, alternative: Dict, primary: Dict) -> Dict:\n        \"\"\"\n        Compare alternative route to primary recommendation\n        \n        Args:\n            alternative: Alternative route data\n            primary: Primary route data\n            \n        Returns:\n            Dict: Comparison metrics\n        \"\"\"\n        if not primary:\n            return {}\n        \n        time_diff = alternative['travel_time_min'] - primary['travel_time_min']\n        fuel_diff = alternative['fuel_consumption_l'] - primary['fuel_consumption_l']\n        co2_diff = alternative['co2_emission_kg'] - primary['co2_emission_kg']\n        \n        return {\n            'time_difference_min': round(time_diff, 1),\n            'fuel_difference_l': round(fuel_diff, 3),\n            'co2_difference_kg': round(co2_diff, 3),\n            'is_faster': time_diff < 0,\n            'is_more_efficient': fuel_diff < 0,\n            'is_more_eco_friendly': co2_diff < 0\n        }\n    \n    def _identify_best_aspect(self, route: Dict) -> str:\n        \"\"\"\n        Identify what this route is best for\n        \n        Args:\n            route: Route data\n            \n        Returns:\n            str: Best aspect description\n        \"\"\"\n        # This would ideally compare across all routes\n        # For now, use heuristics based on route characteristics\n        \n        if route['congestion_score'] < 0.3:\n            return \"Low traffic conditions\"\n        elif route['fuel_consumption_l'] < route.get('distance_km', 20) * 0.07:\n            return \"Fuel efficiency\"\n        elif route['co2_emission_kg'] < route.get('distance_km', 20) * 0.15:\n            return \"Environmental friendliness\"\n        elif route['travel_time_min'] < route.get('distance_km', 20) * 1.5:\n            return \"Speed and time savings\"\n        else:\n            return \"Balanced option\"\n    \n    def _generate_time_recommendations(self, optimization_result: Dict) -> Dict:\n        \"\"\"\n        Generate time-specific recommendations\n        \n        Args:\n            optimization_result: Optimization results\n            \n        Returns:\n            Dict: Time recommendations\n        \"\"\"\n        time_recs = {\n            'peak_hours_warning': [],\n            'optimal_windows': [],\n            'flexibility_suggestions': []\n        }\n        \n        # Analyze routes for time patterns\n        routes = optimization_result.get('ranked_routes', [])\n        \n        if routes:\n            # Check for peak hour conflicts\n            rush_hour_routes = [r for r in routes \n                              if r.get('congestion_score', 0) > Config.CONGESTION_THRESHOLD]\n            \n            if rush_hour_routes:\n                time_recs['peak_hours_warning'].append(\n                    \"‚ö†Ô∏è High traffic expected during requested time window\"\n                )\n                time_recs['peak_hours_warning'].append(\n                    \"Consider departing 1-2 hours earlier or later if possible\"\n                )\n            \n            # Find low-congestion options\n            low_traffic_routes = [r for r in routes \n                                if r.get('congestion_score', 1) < 0.4]\n            \n            if low_traffic_routes:\n                best_time = low_traffic_routes[0]\n                hour = best_time.get('hour', 12)\n                hour_12 = hour % 12\n                if hour_12 == 0:\n                    hour_12 = 12\n                ampm = 'AM' if hour < 12 else 'PM'\n                \n                time_recs['optimal_windows'].append(\n                    f\"‚ú® Optimal departure time: {hour_12:02d}:00 {ampm} \"\n                    f\"(Traffic level: {best_time['traffic_level']})\"\n                )\n        \n        # General flexibility suggestions\n        time_recs['flexibility_suggestions'].extend([\n            \"üïê Consider +/- 30 minutes flexibility for significant traffic improvements\",\n            \"üìÖ Weekend travel typically has 30-50% less congestion\",\n            \"üåÖ Early morning (6-7 AM) and late evening (9-10 PM) are usually optimal\"\n        ])\n        \n        return time_recs\n    \n    def _generate_sustainability_recommendations(self, \n                                               sustainability_analysis: Dict = None) -> Dict:\n        \"\"\"\n        Generate sustainability-focused recommendations\n        \n        Args:\n            sustainability_analysis: Environmental impact analysis\n            \n        Returns:\n            Dict: Sustainability recommendations\n        \"\"\"\n        sustainability_recs = {\n            'current_impact': {},\n            'improvement_opportunities': [],\n            'alternative_modes': [],\n            'annual_projection': {}\n        }\n        \n        if sustainability_analysis:\n            # Extract current impact\n            if 'route_sustainability' in sustainability_analysis:\n                routes = sustainability_analysis['route_sustainability']\n                if routes:\n                    best_route = routes[0]\n                    sustainability_recs['current_impact'] = {\n                        'co2_emission_kg': best_route.get('co2_emission_kg', 0),\n                        'fuel_consumption_l': best_route.get('fuel_consumption_l', 0),\n                        'sustainability_score': best_route.get('sustainability_score', 50)\n                    }\n            \n            # Improvement opportunities\n            potential_savings = sustainability_analysis.get('potential_co2_savings_kg', 0)\n            if potential_savings > 0:\n                sustainability_recs['improvement_opportunities'].append(\n                    f\"üíö Potential CO2 reduction: {potential_savings:.2f} kg \"\n                    f\"({sustainability_analysis.get('potential_savings_percentage', 0):.1f}%)\"\n                )\n        \n        # General sustainability recommendations\n        sustainability_recs['improvement_opportunities'].extend([\n            \"üöå Consider public transportation for 60-80% emission reduction\",\n            \"üö≤ Bike or walk for trips under 5km - zero emissions!\",\n            \"üë• Carpooling can reduce individual carbon footprint by 50%\",\n            \"‚ö° Electric vehicles reduce emissions by 60-70% vs gasoline cars\"\n        ])\n        \n        return sustainability_recs\n    \n    def _generate_traffic_insights(self, optimization_result: Dict) -> List[str]:\n        \"\"\"\n        Generate traffic-related insights\n        \n        Args:\n            optimization_result: Optimization results\n            \n        Returns:\n            List[str]: Traffic insights\n        \"\"\"\n        insights = []\n        \n        routes = optimization_result.get('ranked_routes', [])\n        \n        if routes:\n            # Analyze congestion levels\n            avg_congestion = sum(r.get('congestion_score', 0) for r in routes) / len(routes)\n            \n            if avg_congestion > 0.7:\n                insights.append(\"üî¥ High traffic conditions expected across all route options\")\n                insights.append(\"üí° Consider rescheduling travel if flexibility allows\")\n            elif avg_congestion > 0.4:\n                insights.append(\"üü° Moderate traffic conditions - some delays expected\")\n                insights.append(\"‚è∞ Allow 15-30% extra travel time\")\n            else:\n                insights.append(\"üü¢ Good traffic conditions - minimal delays expected\")\n            \n            # Speed insights\n            speeds = [r.get('avg_speed_kmh', 50) for r in routes]\n            avg_speed = sum(speeds) / len(speeds)\n            \n            if avg_speed < 25:\n                insights.append(\"üêå Slow traffic conditions - expect frequent stops\")\n            elif avg_speed > 50:\n                insights.append(\"üöÄ Good traffic flow expected\")\n            \n            # Distance vs time analysis\n            if routes:\n                best_route = routes[0]\n                distance = best_route.get('distance_km', 0)\n                time = best_route.get('travel_time_min', 0)\n                \n                if distance > 0 and time > 0:\n                    efficiency = distance / (time / 60)  # km/hour\n                    if efficiency < 20:\n                        insights.append(\"‚ö†Ô∏è Traffic congestion significantly impacting travel efficiency\")\n        \n        return insights\n    \n    def _generate_action_items(self, optimization_result: Dict, \n                             user_input: Dict) -> List[Dict]:\n        \"\"\"\n        Generate actionable items for the user\n        \n        Args:\n            optimization_result: Optimization results\n            user_input: User input data\n            \n        Returns:\n            List[Dict]: Action items\n        \"\"\"\n        action_items = []\n        \n        # Primary action\n        if 'best_overall' in optimization_result:\n            best_route = optimization_result['best_overall']\n            hour = best_route.get('hour', 12)\n            hour_12 = hour % 12\n            if hour_12 == 0:\n                hour_12 = 12\n            ampm = 'AM' if hour < 12 else 'PM'\n            \n            action_items.append({\n                'priority': 'high',\n                'action': 'Plan your route',\n                'description': f\"Depart at {hour_12:02d}:00 {ampm} via {best_route['description']}\",\n                'estimated_time_savings': self._calculate_time_savings(optimization_result),\n                'category': 'route_planning'\n            })\n        \n        # Traffic monitoring\n        action_items.append({\n            'priority': 'medium',\n            'action': 'Monitor traffic conditions',\n            'description': 'Check traffic updates 30 minutes before departure',\n            'category': 'preparation'\n        })\n        \n        # Sustainability action\n        action_items.append({\n            'priority': 'low',\n            'action': 'Consider sustainable alternatives',\n            'description': 'Evaluate public transport or carpooling options for regular trips',\n            'category': 'sustainability'\n        })\n        \n        # Flexibility recommendation\n        if user_input.get('preferred_hour'):\n            action_items.append({\n                'priority': 'medium',\n                'action': 'Maintain schedule flexibility',\n                'description': 'Allow +/- 30 minutes flexibility for optimal routing',\n                'category': 'time_management'\n            })\n        \n        return action_items\n    \n    def _calculate_time_savings(self, optimization_result: Dict) -> str:\n        \"\"\"\n        Calculate estimated time savings from optimization\n        \n        Args:\n            optimization_result: Optimization results\n            \n        Returns:\n            str: Time savings description\n        \"\"\"\n        routes = optimization_result.get('ranked_routes', [])\n        \n        if len(routes) >= 2:\n            best_time = routes[0].get('travel_time_min', 0)\n            worst_time = max(r.get('travel_time_min', 0) for r in routes)\n            savings = worst_time - best_time\n            \n            if savings > 5:\n                return f\"Up to {savings:.0f} minutes vs worst option\"\n            else:\n                return \"Minimal time difference between options\"\n        \n        return \"Time savings calculation unavailable\"\n    \n    def _get_recommendation_strength(self, score: float) -> str:\n        \"\"\"\n        Convert optimization score to recommendation strength\n        \n        Args:\n            score: Optimization score\n            \n        Returns:\n            str: Recommendation strength\n        \"\"\"\n        if score <= 0.2:\n            return \"Highly Recommended\"\n        elif score <= 0.4:\n            return \"Recommended\"\n        elif score <= 0.6:\n            return \"Acceptable\"\n        elif score <= 0.8:\n            return \"Marginal\"\n        else:\n            return \"Not Recommended\"\n    \n    def format_for_display(self, recommendations: Dict, \n                          format_type: str = 'detailed') -> str:\n        \"\"\"\n        Format recommendations for display\n        \n        Args:\n            recommendations: Generated recommendations\n            format_type: Type of formatting ('detailed', 'summary', 'json')\n            \n        Returns:\n            str: Formatted output\n        \"\"\"\n        if format_type == 'json':\n            return json.dumps(recommendations, indent=2, default=str)\n        \n        elif format_type == 'summary':\n            return self._format_summary(recommendations)\n        \n        else:  # detailed\n            return self._format_detailed(recommendations)\n    \n    def _format_summary(self, recommendations: Dict) -> str:\n        \"\"\"\n        Format as summary view\n        \n        Args:\n            recommendations: Recommendations data\n            \n        Returns:\n            str: Summary format\n        \"\"\"\n        primary = recommendations.get('primary_recommendation', {})\n        \n        if 'error' in primary:\n            return \"‚ùå No route recommendations available\"\n        \n        lines = [\n            \"üéØ **TRAFFIC ADVISORY RECOMMENDATION**\",\n            f\"üìç {recommendations['request_info']['source']} ‚Üí {recommendations['request_info']['destination']}\",\n            f\"üïê Depart: {primary.get('recommended_departure', 'N/A')}\",\n            f\"üìè Distance: {primary['travel_metrics']['distance_km']} km\",\n            f\"‚è±Ô∏è Time: {primary['travel_metrics']['estimated_travel_time_min']} minutes\",\n            f\"üö¶ Traffic: {primary['travel_metrics']['traffic_level']}\",\n            f\"‚õΩ Fuel: {primary['environmental_impact']['fuel_consumption_l']} L\",\n            f\"üå± CO2: {primary['environmental_impact']['co2_emission_kg']} kg\"\n        ]\n        \n        return \"\\n\".join(lines)\n    \n    def _format_detailed(self, recommendations: Dict) -> str:\n        \"\"\"\n        Format as detailed view\n        \n        Args:\n            recommendations: Recommendations data\n            \n        Returns:\n            str: Detailed format\n        \"\"\"\n        lines = []\n        \n        # Header\n        lines.extend([\n            \"\" + \"=\"*60,\n            \"üö¶ AI-BASED TRAFFIC ADVISORY AGENT\",\n            \"üéØ SDG 11: Sustainable Cities and Communities\",\n            \"=\"*60\n        ])\n        \n        # Request info\n        request = recommendations['request_info']\n        lines.extend([\n            \"\\nüìã **TRIP DETAILS**\",\n            f\"From: {request['source']}\",\n            f\"To: {request['destination']}\",\n            f\"Requested time: {request['preferred_time']}\",\n            f\"Analysis time: {request['timestamp'][:19]}\"\n        ])\n        \n        # Primary recommendation\n        primary = recommendations.get('primary_recommendation', {})\n        if 'error' not in primary:\n            lines.extend([\n                \"\\nüéØ **PRIMARY RECOMMENDATION**\",\n                f\"Route: {primary['route_description']}\",\n                f\"Recommended departure: {primary['recommended_departure']}\",\n                f\"Distance: {primary['travel_metrics']['distance_km']} km\",\n                f\"Estimated travel time: {primary['travel_metrics']['estimated_travel_time_min']} minutes\",\n                f\"Traffic level: {primary['travel_metrics']['traffic_level']}\",\n                f\"Congestion score: {primary['travel_metrics']['congestion_score']}\",\n                f\"Fuel consumption: {primary['environmental_impact']['fuel_consumption_l']} L\",\n                f\"CO2 emissions: {primary['environmental_impact']['co2_emission_kg']} kg\",\n                f\"Recommendation strength: {primary['recommendation_strength']}\"\n            ])\n        \n        # Alternatives\n        alternatives = recommendations.get('alternative_options', [])\n        if alternatives:\n            lines.append(\"\\nüîÄ **ALTERNATIVE OPTIONS**\")\n            for i, alt in enumerate(alternatives[:2], 1):\n                lines.extend([\n                    f\"\\nOption {i}: {alt['route_description']}\",\n                    f\"  Departure: {alt['departure_time']}\",\n                    f\"  Travel time: {alt['key_metrics']['travel_time_min']} min\",\n                    f\"  Traffic level: {alt['key_metrics']['traffic_level']}\",\n                    f\"  Best for: {alt['best_for']}\"\n                ])\n        \n        # Insights\n        insights = recommendations.get('traffic_insights', [])\n        if insights:\n            lines.append(\"\\nüí° **TRAFFIC INSIGHTS**\")\n            lines.extend(f\"  ‚Ä¢ {insight}\" for insight in insights[:3])\n        \n        # Sustainability\n        sustainability = recommendations.get('sustainability_insights', {})\n        improvements = sustainability.get('improvement_opportunities', [])\n        if improvements:\n            lines.append(\"\\nüå± **SUSTAINABILITY TIPS**\")\n            lines.extend(f\"  ‚Ä¢ {tip}\" for tip in improvements[:3])\n        \n        # Action items\n        actions = recommendations.get('action_items', [])\n        if actions:\n            lines.append(\"\\n‚úÖ **ACTION ITEMS**\")\n            for action in actions[:3]:\n                lines.append(f\"  ‚Ä¢ {action['action']}: {action['description']}\")\n        \n        lines.append(\"\\n\" + \"=\"*60)\n        \n        return \"\\n\".join(lines)\n    \n    def export_recommendations(self, recommendations: Dict, \n                             filepath: str = None) -> str:\n        \"\"\"\n        Export recommendations to file\n        \n        Args:\n            recommendations: Recommendations to export\n            filepath: Optional file path\n            \n        Returns:\n            str: Path to exported file\n        \"\"\"\n        if filepath is None:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filepath = f\"traffic_recommendations_{timestamp}.json\"\n        \n        with open(filepath, 'w') as f:\n            json.dump(recommendations, f, indent=2, default=str)\n        \n        return filepath"